{
  "Chapter+2-线性表-Part+1": [
    "第二章 线性表\u000bPart I",
    "目录\n线性结构定义\n线性表的操作设计及应用示例(伪码)\n线性表的顺序表示和实现(顺序表的初始化，元素插入、删除、查找，有序顺序表的合并)\n线性表的链式表示和实现\n单链表的C指针实现(单链表的创建，元素插入、删除、查找，有序表的合并)\n应用：一元多项式\n单链表的C数组实现/静态链表(静态链表的创建、初始化，元素插入、删除、查找)\n应用：集合合并\n双向链表(双向链表的创建、元素插入、删除、查找)\n循环链表",
    "1. 线性结构定义\n线性结构表示数据元素之间的(广义的)有序关系，是最常用、最简单的一种数据结构，包含线性表、栈、队列、串、广义表\n线性结构的特点：\n存在一个唯一的被称为“第一个”的数据元素\n存在一个唯一的被称为“最后一个”的数据元素\n除第一个元素外，每个元素均有唯一一个直接前驱(Immediate predecessor)\n除最后一个元素外，每个元素均有唯一一个直接后继(Immediate successor)\n3",
    "线性表(Linear List)定义\n线性表是由n(n≧0)个数据元素(结点)a1，a2，…，an组成的有限序列，且该序列中的所有结点具有相同的数据类型\n线性表中数据元素的个数n称为线性表的长度\n当n=0时，称为空表\n当n>0时，将非空的线性表记作 (a1，a2，…an)，那么，a1称为线性表的第一个(首)结点，an称为线性表的最后一个(尾)结点，a1，a2，…ai-1都是ai(2≦i≦n)的前驱，其中ai-1是ai的直接前驱，ai+1，ai+2，…an都是ai(1≦i ≦n-1)的后继，其中ai+1是ai的直接后继\n不是\n头结点",
    "线性表的逻辑结构\n线性表中的结点可以是单值元素(每个元素只有一个数据项) \n线性表中的结点可以是记录型元素(记录)\n每个记录含有多个数据项 ，每个项称为结点的一个域\n每个记录有一个可以唯一标识每个结点的数据项组，称为关键字\n若线性表中的结点是按值或按关键字值由小到大(或由大到小)排列的，称线性表是有序的\n\n例：26个英文字母组成的字母表： (A，B，C，…，Z)\n例：某校2001级同学的基本情况：\n{(‘2001414101’，‘张里户’ ，‘男’ ，06/24/1983)，      (‘2001414102’，‘张化司’ ，‘男’ ，08/12/1984)，\n      …，\n     (‘2001414102’，‘李丽丽’ ，‘女’ ，08/12/1984) }\n5",
    "线性表的操作-设计考虑\n基本操作：\n初始化操作，销毁操作\n插入元素，删除元素\n元素定位，求表长，取元素，遍历\n其他操作：利用基本操作可以实现的操作\n将表置空，修改元素\n线性表判空，求前驱，求后继\n合并两个有序列表\n修改=定位+删除+插入",
    "线性表的定义(伪码)\nList {\n数据对象：D = { ai | ai∈ElemSet,  i=1,2,…,n, n≧0 }\n数据关系：R = {<ai-1, ai> | ai-1, ai∈D,  i=2,3,…,n }\n基本操作： … \nGetElem(L, i, &e) //取线性表第i个元素\nLocateElem(L, e, compare) //定位数据元素\n初始条件：线性表L已存在，compare()是对数据元素的判定函数\n操作结果：返回L中第一个与e满足关系compare()的数据元素的位置，若这样的数据元素不存在，则返回值为0\nListInsert ( &L, i, &e ) //插入数据元素\n初始条件：线性表L已存在，1≦i≦ListLength(L) +1；\n操作结果：在线性表L中的第i个位置之前插入元素e，L的长度加1；\nListTraverse(L, visit) //遍历线性表\n初始条件：线性表L已存在\n操作结果：依次对L的每个数据元素调用函数visit()。一旦visit()失败，则操作失败\n…\n}\n7",
    "线性表应用举例1：集合合并，A=AUB\n思路：\n用两个线性表La、Lb表示集合A和B，\n将所有在Lb中但不在La中的数据元素插入到La中\n具体步骤：\n依次察看线性表 Lb的每个数据元素\nGetElem(Lb, i, &e)\n根据元素值在线性表 La 中进行查找\n LocateElem(La, e, equal)\n若不存在，则插入之\nListInsert(&La, n+1, e), n为La的当前长度\n算法的自然语言描述",
    "线性表应用举例1：集合合并，A=AUB\nvoid union (List &La, List Lb){\n\tint La_len,Lb_len,i; \n\tElemType e;\n\tLa_len=ListLength(La); // 求线性表的长度\n\tLb_len=ListLength(Lb);\n\tfor (i=1;i<=Lb_len;i++){\n\t\tGetElem(Lb,i,&e); //取Lb中第i个元素给e\n\t\tIf(!LocateElem(La,e,equal) //若La中无e\n\t\t\tListInsert(La, ++La_len,e);//插入\n\t}//for\n}//union\n9\n2.1\n算法的伪码描述",
    "线性表应用举例2：集合(multiset)去重\n功能：根据一个多重集合 B构造一个集合 A，使得A中只包含B中的所有值各不相同的数据元素\n思路：\n用两个线性表La、Lb表示集合A(初始为空)和B\n将所有在Lb中但不在La中的数据元素插入到La中\n具体步骤：\n构造空的线性表La\n依次察看线性表 Lb的每个数据元素\n根据元素值在线性表 La 中进行查找\n若不存在，则插入之",
    "线性表应用举例2：集合(multiset)去重\nvoid union (List &La, List Lb){\n\tint La_len,Lb_len,i; \n\tElemType e;\n\tInitList(La); // 构造空的线性表La\n\tLa_len=ListLength(La); // 求线性表的长度\n\tLb_len=ListLength(Lb);\n\tfor (i=1;i<=Lb_len;i++){\n\t\tGetElem(Lb,i,e); //取Lb中第i个元素给e\n\t\tIf (!LocateElem(La,e,equal) //若La中无e\n\t\t\tListInsert(La, ++La_len,e);//插入\n\t}//for\n}//union\n11",
    "线性表应用举例3：有序列表合并\nMergeList (La, Lb, &Lc)：将两有序表合并成一新有序表\n功能：合并两有序列表(其值按非递减顺序排列)成一新有序列表\n若 La = (a1, …, ai, …, an)，Lb = (b1, …, bj, …, bm)，\n     Lc = (c1, …, ck, …, cm+n)，\n那么要求由(a1, …, ai-1)和(b1, …,bj-1)归并得到 (c1, …, ck-1)，其中，",
    "具体步骤\n初始化 Lc 为空表\n(La、Lb不空)分别从 La和Lb中取得当前元素 ai 和 bj\n若 ai≤bj，则将 ai 插入到 Lc 中，否则，将bj 插入到 Lc中\n重复 2 和 3 两步，直至 La或 Lb 中的元素      被取完为止\n将 La表或 Lb 表中剩余元素复制插入到 Lc表中",
    "线性表应用举例3：有序列表合并\nvoid MergeList(List La, List Lb, List &Lc) {\n\tint La_len, Lb_len; ElemType ai, bj; \n\tint i=1, j=1, k=0;\n\tInitList(Lc);  //初始化Lc为空表\n\tLa_len=ListLength(La);\n\tLb_len=ListLength(Lb); \n\twhile((i<=La_len)&&(j<=Lb_len)) {\n\t\t//La和Lb均非空…\n\t}\n\twhile(i<=la_len) {//La不空…\n\t\t}\n\twhile(j<=Lb_len){//Lb不空…\n\t\t}\n}//MergeList\n14\n2.2",
    "线性表应用举例3：有序列表合并\nvoid MergeList(List La, List Lb, List &Lc) {\nint La_len, Lb_len; ElemType ai, bj; int i=1, j=1, k=0;\nInitList(Lc);  //初始化Lc为空表\nLa_len=ListLength(La);Lb_len=ListLength(Lb); \nwhile((i<=La_len)&&(j<=Lb_len)) {//La和Lb均非空\n\tGetElem(La,i,&ai);GetElem(Lb,j,&bj); //取当前元素\n\tif(ai<=bj) { //将ai插入Lc\n\t\tListInsert(Lc,++k,ai);++i;} \n\telse {//将bj插入到Lc\n\t\tListInsert(Lc,++k,bj);++j;}\n\t}\nwhile(i<=la_len) {\n\t\t//将 LA 表中剩余元素复制插入到LC 表中\n\t\tGetElem(La,i++,ai); ListInsert(Lc,++k,ai); \n\t\t}\nwhile(j<=Lb_len){\n\t\tGetElem(Lb,j++,bj);ListInsert(Lc,++k,bj);\t\n\t\t}\n}//MergeList\n15\n2.2\n时间复杂度？\n最坏情况下的\n时间复杂度为\nO(m2+n2)",
    "常见的指针操作\nC语言复习",
    "C语言复习",
    "函数参数的两种传递方式\nint  func1(int  para) //值传递\n {\tpara = para * 2;\n     \treturn  para;\n}\nvoid  func2(int  &para) //引用传递\n{     \tpara = para * 2;\n     \treturn;\n}\n\n//用指针来实现引用传递\nvoid func3(int *para) \n{*para=*para*2;\nreturn;\n}\nint main() \n{    int a, b, c;\n     a = 2; c=4;\n     b = func1(a);\n     func2(a);\n     func3(&c);\n     return 0;\n}\n编程语言复习\nC中，无引用传递\nC++中，有引用传递\n用C指针来实现引用传递",
    "2. 线性表的顺序表示和实现\n线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素\n用存储位置的相邻来表示数据元素之间的有序关系\n设有非空的线性表(a1，a2，…an)，而每个元素需占用X个存储单元\n顺序表(Sequential list)： LOC(ai+1)=LOC(ai) + X\n基地址",
    "线性表的顺序实现：用动态分配的一维数组\n#define LIST_INIT_SIZE  100 //线性表初始大小\n#define LISTINCREMENT 10 //线性表增量大小\ntypedef struct{ \nElemType *elem; //线性表存储空间的基地址\nint listsize; //当前分配的存储容量\n\t\t//以sizeof(ElemType)为单位\nint length; //线性表当前长度\n} SqList;\ntypedef int ElemType;\ntypedef struct {\nint  y;        // Year \nint  m;       // Month\nint  d;        // Day\n} ElemType;\ntypedef int Status;",
    "线性表的基本操作在顺序表中的实现\n// 1. 线性表的初始化\nStatus InitList_Sq ( SqList *L )\n// 2. 在第i个元素之前插入元素e\nStatus ListInsert_Sq(SqList *L, int i, ElemType e)\n// 3. 删除第i个元素，并带回删除的值\nStatus ListDelete_Sq(SqList *L, int i, ElemType *e)\n// 4. 定位元素\nStatus LocateElem_Sq(SqList *L, ElemType e, \nStatus (*compare)(ElemType, ElemType)) \n// 5. 两有序表合并成一新有序表\nStatus MergeList_Sq(SqList *La, SqList *Lb, SqList *Lc)",
    "1. 线性表的初始化\nStatus InitList_Sq ( SqList *L ){ \n//构造一个空的、容量为LIST_INIT_SIZE的线性表L\nL->elem = (ElemType *)malloc(LIST_INIT_SIZE *sizeof( ElemType ) ) ;\nif (!L->elem ) return OVERFLOW;// 存储分配失败\nL->length= 0; \t\t\t   //空表长度为0\nL->listsize = LIST_INIT_SIZE; \t   //初始存储容量\nreturn OK; \n} // InitList_Sq\n2.3\n时间复杂度？\nO(1)",
    "2. 元素插入：在第i个元素之前插入元素e\nStatus ListInsert_Sq(SqList *L, int i, ElemType e)\n(a1, …, ai-1, ai, …, an)   改变为\n<ai-1, ai>\n<ai-1, e>,  <e, ai>\n(a1, …, ai-1, e, ai, …, an)",
    "Status ListInsert_Sq(SqList *L, int i, ElemType e)\nElemType *p;\nElemType *q= &(L->elem[i-1]); //q为插入位置\n//插入位置及之后的元素右移\nfor(p=&(L->elem[L->length-1]);p>=q;--p)\n\t *(p+1) =*p; \n*q =e;\t //插入e\nL->length ++;//表长增1\nL->length-1\n0\n87\n56\n42\n66\n举例：ListInsert_Sq(L, 5, 66)",
    "元素插入-1\nStatus ListInsert_Sq(SqList *L, int i, ElemType e) { ElemType *p;\n\n// 操作执行条件检查…\nElemType *q= &(L->elem[i-1]); //q为插入位置\n//插入位置及之后的元素右移\nfor(p=&(L->elem[L->length-1]);p>=q;--p)\n\t *(p+1) =*p; \n*q =e;\t //插入e\nL->length ++; //表长增1\nreturn OK;\n}//ListInsert_Sq\n2.4",
    "元素插入-2\n// Status ListInsert_Sq(SqList *L, int i, ElemType e)\n// 操作执行条件检查\nif(i <1 || i > L->length+1) return ERROR; //i值不合法\nif(L->length>= L->listsize){\n\t// 当前存储空间已满，增加容量\n\t ElemType *newbase = \n\t    (ElemType *) realloc(L->elem, \n\t    (L->listsize+LISTINCREMENT) \n\t    *sizeof(ElemType));\n\tif (!newbase) return ERROR; // 存储分配失败\n\tL->elem = newbase; //新的基地址\n\tL->listsize += LISTINCREMENT; //新的存储容量\n\t}\ni = L->length+1也是合法的，即，可以把元素插在 list的最后一个元素之后",
    "第i个元素之前插入新结点：时间复杂度分析",
    "3. 元素删除：删除线性表的第i个元素\nStatus ListDelete_Sq(SqList *L, int i, ElemType *e)\n(a1, …, ai-1, ai, ai+1, …, an) 改变为\nai+1\n…\nan\n<ai-1, ai>, <ai, ai+1>\n<ai-1, ai+1>\n表的长度减少\n(a1, …, ai-1, ai+1, …, an)\n断点续讲",
    "Status ListDelete_Sq(SqList *L, int i, ElemType *e)\nL->length-1\n0\n87\n56\n举例: ListDelete_Sq ( *L,  5, *e)\nElemType *p, *q;\np = &(L->elem[i-1]); // p为被删除元素的位置\n*e = *p; // 被删除元素的值赋给e\nq = L->elem+L->length-1;   // q为表尾元素的位置\n// 被删除元素之后的元素左移\nfor (++p; p<=q; ++p) *(p-1) = *p; \nL->length--; // 表长减1",
    "元素删除：删除线性表的第i个元素\nStatus ListDelete_Sq(SqList *L, int i, ElemType *e) {  \n ElemType *p, *q;\n if ((i<1) || (i>L->length)) return ERROR; //i值不合法\n p = &(L->elem[i-1]);          // p为被删除元素的位置\n *e = *p;                               // 被删除元素的值赋给e\n q = L->elem+L->length-1; // q为表尾元素的位置\n for (++p; p<=q; ++p) \n\t*(p-1) = *p;  // 被删除元素之后的元素左移\n  L->length--;           // 表长减1\n  return OK;\n} // ListDelete_Sq\n2.5",
    "删除第i个元素：时间复杂度分析",
    "4. 在线性表中查找元素e\n// L中查找第1个值与e满足compare()的元素的位置\nStatus LocateElem_Sq(SqList *L, ElemType e, \n\t\tStatus (*compare)(ElemType, ElemType))  \n\n#define LESS -1\n#define GREATER 1\nStatus (*compare)(ElemType a, ElemType b)\n{\n  if (a<b) return LESS;\n  if (a>b) return  GREATER;\n  return 0;\n}\n\n在主程序中的调用方式：\nElemType I = LocateElem_Sq(L, 100, compare);\n2.6",
    "4. 在线性表中查找元素e\n// L中查找第1个值与e满足compare()的元素的位置\nStatus LocateElem_Sq(SqList *L, ElemType e, \nStatus (*compare)(ElemType, ElemType))  { \nint i; ElemType *p; \ni = 1; // i的初值为第1个元素的位置 \np = L->elem; // p的初值为第1个元素的存储位置 while (i <= L->length && (*compare)(*p, e)!=0) { \tp++; i ++;} \nif (i <= L->length) return i; \nelse return 0; \n} // LocateElem_Sq\n2.6\n基本操作：进行两个元素的比较\n        若L中存在和e相同的元素a，\n则比较次数为i (1<=i<=L->length)\n否则比较次数为L->length\n时间复杂度O(L->length)",
    "5. 合并两有序列表成一新有序列表Lc\nStatus MergeList_Sq(SqList *La, SqList *Lb, SqList *Lc) {\nElemType *pa,*pb,*pc,*pa_last,*pb_last; \npa = La->elem; pb = Lb->elem; \npa_last = La->elem+La->length-1;\npb_last = Lb->elem+Lb->length-1; \nLc->listsize = Lc->length = La->length+Lb->length; \npc = Lc->elem = (ElemType*)malloc(\n\t\t\t\tLc->listsize*sizeof(ElemType)); \nif (!Lc->elem) return OVERFLOW; // 存储分配失败 \nwhile (pa <= pa_last && pb <= pb_last) { // 归并 \n\tif (*pa <= *pb) *pc++ = *pa++; // 按值非递减插入\n\telse *pc++ = *pb++; } \nwhile (pa <= pa_last) *pc++ = *pa++; // 插入La的剩余元素 \nwhile (pb <= pb_last) *pc++ = *pb++; // 插入Lb的剩余元素 \nreturn OK;} // MergeList, 算法2.2的实现\n2.7\n时间复杂度\nO(La->length+Lb->length)"
  ],
  "Chapter+2-线性表-Part+2": [
    "第二章 线性表\u000bPart II",
    "目录\n线性结构定义\n线性表的ADT及应用示例\n线性表的顺序表示和实现(顺序表的初始化，元素插入、删除、查找，有序顺序表的合并)\n线性表的链式表示和实现\n单链表的C指针实现(单链表的创建，元素插入、删除、查找，有序表的合并)\n应用：一元多项式\n单链表的C数组实现/静态链表(静态链表的创建、初始化，元素插入、删除、查找)\n应用：集合合并\n双向链表(双向链表的创建、元素插入、删除、查找)\n循环链表\n2",
    "3. 线性表的链式表示和实现\n线性表的链式存储是指用一组任意的(连续的或不连续的)存储单元存储线性表中的数据元素\n为了正确表示数据元素与其直接后续数据元素之间的逻辑关系，在存储每个元素值的同时，还必须存储指示其直接后继的地址(或位置)，称为指针(pointer)或链(link)，这两部分组成了链表中的结点\n指针建立了数据元素之间的逻辑关系\n3",
    "线性表的链式存储实例",
    "线性表的链式存储\n链表(linked list)是通过每个结点的指针域将线性表的n个结点按其逻辑次序链接在一起的\n线性链表(linear linked list)/单链表(singly linked list)：每一个结点只包含一个指向直接后继的指针域\n基于C指针实现的单链表\n基于C数组实现的单链表/静态链表(Static linked list)\n双向链表(doubly linked list)：每一个结点包含两个指针域，其一指向直接后继，另一指向直接前驱\n循环链表(circular linked list)：整个链表的指针域链接成一个或多个环\n双向循环链表(circular doubly linked list)：将头结点和尾结点链接起来的双向链表\n5",
    "线性链表/单链表\n为操作方便，总是在链表的第一个结点之前附设一个头结点：头结点的数据域可以不存储任何信息(或存储链表长度等信息)，头结点的指针域存储指向第一个结点的指针(即第一个结点的存储位置)\n用C语言中的“指针”：head next  data\n头结点head\n头指针\n空指针\n线性表为空表时，\n头结点的指针域为空\n\n6",
    "3.1单链表的C指针实现\n结点的类型定义\ntypedef  struct  Lnode {\n \tElemType  data;  /*数据域，保存结点的值*/\n\tstruct   Lnode  *next;            /*指针域*/\n} Lnode, LinkedList; /*结点、链表的类型 */\n\n结点的赋值//该结点包含一单值元素\nLNode  *p;\np=(LNode*)malloc(sizeof(LNode)); \np->data=20;  p->next=NULL ;\n链表不是随机存取(random access)结构\n7",
    "线性表的基本操作在单链表中的实现\n//1. 生成n个元素的链表\nLinkedList *CreateList_L(int n)\n// 2. 在第i个元素之前插入元素e\nStatus ListInsert_L(LinkedList *L, int i, ElemType e)\n//3. 删除第i个元素\nStatus ListDelete_L(LinkedList *L, int i, ElemType *e)\n//4. 取第i个元素\nStatus GetElem_L(LinkedList *L,int i, ElemType *e)\n//5. 两有序表合并成一新有序表\nLinkedList *MergeList_L(LinkedList *La, LinkedList *Lb)\n8",
    "1. 创建单链表\n逆序输入 n 个数据元素的值，建立带头结点的单链表\n具体步骤：\n建立一个空表\n输入数据元素an，建立结点并插入\n\n输入数据元素an-1，建立结点并插入\n\tp->next=L->next\n\tL->next=p\n依次类推，直至输入a1为止\nan\nan\nan-1\np\nL\nL\nL\n9",
    "创建单链表\nLinkedList *CreateList_L(int n) {\n//逆序输入随机生成的n个元素的值\n//建立带表头结点的单链表L \nLinkedList *L,*p;  int i; \n//先建立一个带头结点的空单链表\nL = (LinkedList *)malloc(sizeof(LNode)); \nL->next = NULL; \nfor (i=n; i>0; --i) { \n  p = (LinkedList *)malloc(sizeof(LNode)); // 生成新结点 \n  p->data =random(200);//随机生成一个200以内的数字 \n  p->next = L->next; L->next = p;  // 插入到表头\n } \nreturn L;\n} // CreateList_L\n2.11\n时间复杂度O(ListLength(L))\nsrand((unsigned)time(NULL));\nrand() % 200;\n10",
    "2. 单链表的元素插入\n将值为e的新结点插入到表的第i个结点的位置上\n首先找到第i-1个结点p，然后生成一个数据域为e的新结点s，并将s结点作为p的直接后继结点\n解决了顺序表的插入操作需要移动大量元素的问题\np\ns\n修改第i-1个结点的指针\ns->next=p->next;\np->next=s;\n合法的 i 是 [1, len(L)+1]\n11",
    "单链表的元素插入\nStatus ListInsert_L(LinkedList *L, int i, ElemType e) {\n//在带头结点的单链表L的第i个元素之前插入元素e \nLinkedList *p, *s; \np = L; int j = 0; \nwhile (p && j < i-1) {// 寻找第i-1个结点\n\tp = p->next; ++j; } \n// i 小于1(导致j>i-1成立)或者大于表长+1(导致p为NULL)\nif (!p || j > i-1) return ERROR;\ns = (LinkedList *)malloc(sizeof(LNode)); // 生成新结点\ns->data = e; \ns->next = p->next; p->next = s; // 插入L中\nreturn OK; \n} // LinstInsert_L\n2.9\n时间复杂度O(n),\n n为链表的长度\n12",
    "3. 单链表的结点删除：按序号删除\n思路：为了删除第i个结点ai，必须找到结点的存储地址。该存储地址是在其直接前趋结点ai-1的next域中，因此，必须首先找到ai-1的存储位置p，然后令p–>next指向ai的直接后继结点，即把ai从链上摘下，最后释放结点ai的空间\n解决了顺序表的删除操作需要移动大量元素的问题\nq = p->next;   p->next = q->next;  \n*e = q->data;   free(q);\np\nq\n13",
    "单链表的第i个元素删除\nStatus ListDelete_L(LinkedList *L, int i, ElemType *e) {\n//在带头结点的单链表L中删除第i个元素，并由e返回其值\nLinkedList *p,*q; p = L; int j = 0;\nwhile (p->next && j < i-1) { \n\t// 寻找第i个结点的前驱，并令p指向该前趋 \n\tp = p->next; ++j; } \n// i小于1(导致j>i-1成立)或者大于表长(导致pnext为NULL)\nif (!(p->next) || j > i-1) return ERROR; \nq = p->next; p->next = q->next; // 删除并释放结点\n*e = q->data; free(q); \nreturn OK; \n} // ListDelete_L\n2.10\n算法时间复杂度为O(n)，n为单链表长度\n合法的 i 是 [1, len(L)]\n14",
    "单链表的结点删除\n删除单链表中值为key的第一个结点 \n删除单链表中值为key的所有结点\n从单链表的第一个结点开始，对每个结点进行检查，若结点的值为key，则删除之，然后检查下一个结点，直到所有的结点都检查到\n删除单链表中所有值重复的结点，使得所有结点的值都不相同\n从单链表的第一个结点开始，对每个结点进行检查：检查链表中该结点的所有后继结点，只要有值和该结点的值相同，则删除之；然后检查下一个结点，直到所有的结点都检查到\n15",
    "4. 取第i个元素\n思路：从链表的头结点出发，沿链域next逐个结点往下搜索，直到搜索到第i个结点为止\n具体步骤：\n令指针 p 指向线性表中第 j 个数据元素\n移动指针，比较 j 和 i\n举例：GetElem_L(L, 3, e), 其中，LinkedList *L，ElemType *e\nj\n1\n2\n3\ne=30\n16",
    "单链表的元素查找：按序号查找\nStatus GetElem_L(LinkedList *L,int i, ElemType *e) {\n// L为带头结点的单链表的头指针\n\n// 当第i个元素存在时，其值赋给e并返回OK，否则返回ERROR \n// 初始化，p指向第一个结点，j为计数器\nLinkedList *p; p = L->next; int j = 1; \nwhile (p && j<i) { \n      //顺指针向后查找，直到p指向第i个元素或p为空\n      p = p->next; ++j; } \nif ( !p || j>i ) return ERROR; // 第i个元素不存在 \n*e = p->data; // 取第i个元素 \nreturn OK; \n} // GetElem_L\n2.8\n合法的 i 是 [1, len(L)]\n17",
    "单链表的查找\n单链表的查找：按序号查找\n假设n为链表的长度，序号为i\n步骤：比较i和j，并后移指针p\n循环体内语句执行频度与i值有关：\ni<1时：0次； i∈[1,n]：i-1次；i>n：n次\n\n\n单链表的查找：按值查找\n查找是否有结点值等于给定值key的结点\n步骤：从头结点出发，沿链表逐个将结点的值和给定值key作比较。若相等，则返回首次找到的值为key的结点的存储位置；否则返回NULL\n算法时间复杂度为O(n)\nn为单链表长度\n18",
    "5. 有序单链表的合并\n两个有序的单链表La ，Lb的初始状态\npc->next=pa;\npc=pa;\npa=pa->next\npc->next=pb;\npc=pb;\npb=pb->next",
    "将两个有序链表合并为一个有序链表\nLinkedList *MergeList_L(LinkedList *La, LinkedList *Lb) {\n//合并 两非递减单链表La和Lb，形成新的单链表Lc，Lc的元素也按值非递减排列。pa, pb为两个链表的当前结点\nLinkedList *Lc, *pa, *pb, *pc; //pc为合并后链表的最后一个结点\npa = La->next; pb = Lb->next; \nLc = pc = La; // 用La的头结点作为Lc的头结点 \nwhile (pa && pb) {\n  if (pa->data <= pb->data) {\n\t pc->next = pa; pc = pa; pa = pa->next; } \n  else { pc->next = pb; pc = pb; pb = pb->next; } } \npc->next = pa ? pa : pb; // 插入剩余段 \nfree(Lb); // 释放Lb的头结点\nreturn Lc;  \n} // MergeList_L\n2.12\n合并的时间复杂度O(m+n),\n m、n为链表La、Lb的长度\n20",
    "改进链表\n存在的问题：\n链表的表长是隐含的\n对输入数据的合法性检查，被推迟\n若要在链表的最后一个元素之后插入元素，那么要遍历整个链表\n结点的当前位置很重要\n改进的措施：\n增加变量，分别表示：表长、表尾、当前位置\n将操作中的参数“位序 i ”改为“当前位置”\n21",
    "改进的单链表\n// 结点类型\ntypedef struct LNode {  \n\tElemType       data;\n\tstruct LNode   *next;\n} Link, Position; \n// 链表类型\ntypedef struct {\n// head, tail分别指向头结点和最后一个结点的指针\nLink  *head, *tail; \n// current指向当前被访问的结点的指针\nLink  *current; //其初始位置指向头结点\nint   curpos;     //指示当前指针位置,初值为0\nint   len; \t      //指示链表长度\n} LinkedList;\n22",
    "两种设计比较-接口\n//1: head, tail, len\n//已知p指向L的一个结点，返回p的前驱的位置\nPosition *PriorPos(LinkedList *L, Link *p); \n\n//已知p指向链表的一个结点，返回p所指的数据元素\nElemType *GetCurElem (Link *p );  \n\n//使得p指向L的第i个结点，并返回OK\nStatus LocatePos(LinkedList *L, int i, Link *p);\n // 将s所指结点插入在L的p所指结点之后\nStatus InsAfter (LinkedList *L, Link *p, Link *s );\n//2: 1 + current, curpos\n// 改变当前指针指向其前驱\nStatus Prior(LinkedList *L );  \n\n\n\n// 返回当前指针所指数据元素\nElemType *GetCurElem (LinkedList *L ); \n\n\n// 改变当前指针指向第i个结点\nStatus LocatePos( LinkedList *L, int i );\n\n\n// 将元素 e 插入在当前指针之后\nStatus InsAfter (LinkedList *L, Elemtype e );",
    "链表的基本操作-创建及初始化\n//构造一个空的线性链表 L \n//其头指针、尾指针均指向头结点，表长为零\nLinkedList *InitList(){\nLinkedList *L; Link *p;\n\tL=(LinkedList *)malloc(sizeof(LinkedList));  if (!L) return NULL; \n\tp=(Link *)malloc(sizeof(LNode));  if(!p) return NULL;\n\tL->len=0; L->head=L->tail=p; return L; \n}\n//销毁线性链表 L，L不再存在\nStatus DestroyList( LinkedList *L );\n\n//分配一个值为e的结点，并返回；\n// 若分配失败，则返回 NULL\nLink *MakeNode(ElemType e);\n// 释放 p 所指结点\nvoid   FreeNode( Link *p );\nO(1)\nO(n)\n设链表长度为n\n24",
    "链表的基本操作\n//使得p指向L的第i个结点，并返回p\nStatus LocatePos(LinkedList *L, int i, Link *p){\nint j=1;\n\tp=L->head;\n\twhile(p && j<=i) { //寻找第i个结点\n \t\tp = p->next; j++; }\n\tif (!p) return ERROR; \n\treturn OK;}\n\n//将s所指结点插入在链表L的h所指的结点之后\nStatus InsAfter (LinkedList *L, Link *h, Link *s){\n\tif(!L->head) return ERROR;\n\tL->len++;\n\tif (L->tail==h)L->tail=s;\n\ts->next=h->next; h->next=s;\n\treturn OK;}\nO(n)\nO(n)\n25",
    "链表的基本操作-插入元素\nStatus ListInsert_L(LinkedList *L, int i, ElemType e) \n{ //在链表 L 的第 i 个结点之前插入元素 e\nLink *p,*s;\nint j=1;\np=L->head;\nwhile (p && j<i-1) {//寻找第i-1个结点\n        p=p->next;j++;}\nif(!p || j>i-1) return ERROR;\ns= MakeNode(e); if (!s)return ERROR; \nif(L->tail==p) L->tail=s;\nL->len++;\ns->next=p->next; p->next=s;\nreturn OK;\n}\n26",
    "链表的基本操作-插入元素\nStatus ListInsert_L(LinkedList *L, int i, ElemType e) \n{ //在链表 L 的第 i 个结点之前插入元素 e\nLink *h,*s; \nif(LocatePos(L, i-1,h) ==ERROR ) \n\treturn ERROR; // i值不合法\ns=MakeNode(e);\n\tif (!s) return ERROR; // 结点存储分配失败 \n//将s插入在h之后\nif (InsAfter(L, h, s)==OK) return OK; \nelse return ERROR; \n} // ListInsert_L\n2.20\n利用已有操作实现\n27",
    "单链表的应用：一元多项式\n一元多项式 pn(x)=p0+p1x+p2x2+ … +pnxn\n在计算机中，pn(x)可用线性表P=(p0 ，p1 ，p2 ，… ，pn )表示，每一项的指数i隐含在其系数pi的序号里\n但是，面对p(x) = 1 + 3x10000 – 2x20000，上述表述的问题是浪费大量空间\n一般情况下，一元多项式可以表示成：\n\tpm(x)=p1xe1+p2xe2+ … +pmxem\n其中，pi是指数为ei 的项的非零系数(1<=i<=m)，\n            0≤ e1 < e2 < ┄ < em = n\n那么，pm(x)可以表示成如下的线性表：\n\t((p1,e1),(p2,e2),…,(pm,em))\n用于表示稀疏多项式时，可节省空间\n\t((1,0),(3,10000),(-2,20000))\n但最坏情况下，需要比前一种多一倍的存储空间\n28",
    "一元多项式\n设计选择：用顺序表示还是链式表示？\n取决于要解决的问题的特性：引用型操作多，还是加工型操作多\n一元多项式的加法：\n指数不同：链表的合并\n指数相同：系数相加，若和为0，则去掉结点；若和不为0，则修改结点的系数域\n思路一：\n在原来两个多项式链表的基础上进行相加，相加后原来两个多项式链表就不在存在\n思路二：\n对两个多项式链表进行相加，生成一个新的相加后的结果多项式链表，原来两个多项式链表依然存在，不发生任何改变\n一元多项式，加工操作多，故用链表\n29",
    "一元多项式\n//用带头结点的有序链表表示多项式\ntypedef struct node{\n\tint c;\t//多项式，系数， 可以用float类型\n\tint e;\t//多项式，指数\n\tstruct node *next;\n}Polynomial;\n\n//创建表示一元多项式的有序链表P，带头结点\nPolynomial *Create(int m);\n//多项式相加pa=pa+pb，并销毁pb\nvoid Plus(Polynomial *pa, Polynomial *pb);\n30",
    "创建一元多项式\n// 输入m项的系数和指数，建立表示一元多项式的有序链表P \nPolynomial *Create(int m){  \nPolynomial *head,*p,*q; int i;\n// 生成头结点\np=head=(Polynomial*) malloc(sizeof(Polynomial)); for(i=1;i<=m;i++){ //依次输入m个非零项 \n    q=(Polynomial *)malloc(sizeof(Polynomial));\n    scanf(“%d %d”,&q->c,&q->e); \n    p->next = q;\n    p=q; }\np->next=NULL;\nreturn head;\n} // Create\n2.22\n31",
    "一元多项式加法pa=pa+pb\nvoid Plus(Polynomial *pa,Polynomial *pb){\nPolynomial*h,*p1,*p2,*q; \nh=pa; p1=pa->next;p2=pb->next; //p1,p2分别指向pa和pb的第一个结点\nwhile(p1!=NULL && p2!=NULL)\n    switch(Compare(p1->e, p2->e)) { \n    case 1: { //p1所指结点的指数值大，将p2的结点连接到h\n        \th->next=p2; h=p2; p2=p2->next;\n        \tbreak; }\n    case -1: {//p2所指结点的指数大，将p1的结点连接到h\n \th->next=p1; h=p1; p1=p1->next;\n        \tbreak;}\n    case 0: { // p1, p2的指数一样大\n\t… // 见下页\n\t}\n }\nif(p1!=NULL) h->next =p1;\nelse h->next= p2;\nfree(pb);}\n2.23\n32",
    "一元多项式加法pa=pa+pb\n// 接前页，指数项相同的情况 \nif(p1->c + p2->c !=0) { //系数相加，和不为0，修改p1的系数\n            p1->c =p1->c +p2->c;\n            h->next=p1; h=p1; p1=p1->next;\n            q=p2; p2=p2->next; free(q);\n        }\nelse { //系数相加，和为0，则去掉结点\n        q=p1;p1=p1->next; free(q);\n        q=p2;p2=p2->next; free(q);\n        }\n\nStatus Compare(int a, int b){\n    if(a>b) return 1;\n    if(a<b) return -1;\n    return 0;\n}\n33",
    "3.2单链表的C数组实现：静态链表\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n在“Li”后插入“Shi”，删除“Zheng”之后的\n数组的一个分量表示一个结点，用数组下标/游标代替指针指示结点在数组中的相对位置\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n头结点",
    "静态链表：定义和例子\n#define MAXSIZE 1000\ntypedef struct SLinked{\nElemType data;\nint cur;\n} SLinkedList[MAXSIZE];\nSLinkedList s; \n\n在该存储数组中，可以包含一个空闲链表和多个静态链表\n用(s,head)表示在s中存储的以head为起始位置的静态链表\n数组下标    数据域    指针域\n链表的\n尾结点",
    "基本操作在静态链表中的实现\n//1. 静态链表的初始化：在存储数组中建立空闲链表\nvoid InitList(SLinkedList space);\n//2. 创建一个含有n个结点的静态链表，返回表头在存储数组的位置\nint CreateList(SLinkedList space, int n);\n//3. 在以head为表头的静态链表中，在第i个结点之前插入一个值为x的新结点\nint Insert(SLinkedList space, int head, int i, ElemType x);\n//4. 在以head为表头的静态链表中，删除第i个结点\nint Delete(SLinkedList space, int head, int i, ElemType *e);\n//5. 在以head为表头的静态链表中，确定第一个值为x的结点的位置\nint Locate(SLinkedList space, int head, ElemType x);\n36",
    "1. 静态链表的初始化\n//将一维数组space中各分量链成一个空闲链表\n//space[0].cur为空闲链表的头指针，0表示空指针 \nvoid InitList(SLinkedList space){\nfor(int i=0;i<MAXSIZE-1;i++)\n        space[i].cur=i+1;\n    space[MAXSIZE-1].cur=0;\n}\n2.14\n37",
    "2. 创建一个静态链表\n//创建一个含有n个结点的静态链表，返回表头在存储数组的位置\nint CreateList(SLinkedList space,int n){ \nint head,k,s,i;\nk=AllocNode(space); //从空闲链表中取得一个空结点\nhead=k;\nfor(i=1;i<=n;i++){\n    s=AllocNode(space);\n    scanf(\"%d\",&space[s].data);\n    space[k].cur=s;\n    k=s;\n    }\nspace[k].cur=0;\nreturn head;\n}\n38",
    "从空闲链表中分配一个结点和释放一个结点\n// 若空闲链表非空，则返回分配的结点下标，否则返回0 \nint AllocNode(SLinkedList space){\nint i;\ni=space[0].cur;\nif(i==0) return 0;\nspace[0].cur=space[i].cur;\nreturn i;\n}\n\n// 将下标为i的空闲结点回收到备用链表(的首部)\nvoid FreeNode(SLinkedList space,int i){\nspace[i].cur=space[0].cur;\nspace[0].cur=i;\n}\n2.15\n2.16\n39",
    "3. 在静态链表中插入结点\n//在以head为表头的静态链表中，在第i个结点之前插入一个值为x的新结点\nint Insert(SLinkedList space, int head, int i, ElemType x){\nint j,k,m; \nif(i<1) return 0;\nk=head; j=0;\nwhile (k!=0 && j<i-1){ //查找第i-1个结点\n    j++; k=space[k].cur; }\nif(k==0) return 0;\nm=AllocNode(space); //从空闲链表中获取结点，m为该结点下标\nif (m!=0) {\n        space[m].data=x;\n        space[m].cur=space[k].cur;\n        space[k].cur=m;\n        return 1;\n    } else return 0; \n}\n40",
    "4. 删除静态链表中的第i个结点\n//在以head为表头的静态链表中，删除第i个结点\nint Delete(SLinkedList space, int head, int i, ElemType *e){\nint j,k,m; \nif(i<1) return 0;\nk=head; j=0;\nwhile (k!=0 && j <i-1){ //查找第i-1个结点\n       j++;k=space[k].cur;}\nif(k==0) return 0;\nm=space[k].cur;\nspace[k].cur=space[m].cur;\n*e=space[m].data;\nFreeNode(space, m);\nreturn 1;\n}\n41",
    "5. 在静态链表中查找值为x的结点\n//在以head为表头的静态链表中，确定第1个值为x的结点的位置\n//若找到，则返回它在存储数组中的位置，否则返回0\nint Locate(SLinkedList space, int head, ElemType x){\nint k;\nk=space[head].cur; \n// k指示静态链表中的第一个结点 \nwhile(k!=0 && space[k].data!=x)\n    k=space[k].cur; //顺链查找\nreturn k;\n}\n2.13\n42",
    "静态链表的应用：集合合并\n功能：合并集合A、B：(A-B) U (B-A)\n例如：A={1,3,6}，B={3,5,6}\n合并后的集合A ={1,5}\n\n算法思想：\n建立表示集合A的静态链表S\n在输入集合B的元素时，查找S表\n若存在和B相同的元素，则从S表中删除掉，否则，将此元素插入S表\n43",
    "集合合并\nvoid MergeAB(SLinkedList A, int ha,SLinkedList B, int hb){\nint i,j,k,m; ElemType x;\nj=B[hb].cur;\nwhile(j!=0) { //对hb中的每个结点，进行下面的步骤\n    x=B[j].data;\n    i=Locate(A, ha, x); //链表ha中查找有无hb中的元素\n    if(i==0) //将该元素插入ha，成为ha的第一个元素\n\tInsert(A,ha,1,x); \n    else { //ha有hb中的元素，则将该元素从ha中删除\n\tm=0; k=ha; //寻找要被删除的x在ha中的位置\n           while(k!=i){m++;k=A[k].cur;}\n\tDelete(A, ha, m, &x);  }\n    j=B[j].cur; \n}}\n2.17\n44",
    "3.3双向链表(Doubly Linked List)\n双向链表：构成链表的每个结点中设立两个指针域，一个指向其直接前趋的指针域prior，一个指向其直接后继的指针域next\ntypedef struct node {\nElemType  data ;\nstruct node  *prior , *next ;\n} DoublyLinkedList; \n特性：\nDoublyLinkedList  *p; \nppriornext = p = pnextprior\n双向链表结点形式\n带头结点的双向链表形式\n断点续讲\n45",
    "基本操作在双向链表中的实现\n//1. 创建长度为n的双向链表\nDoublyLinkedList *CreateDoublyLinkedList(int n);\n//2. 在双向链表中查找第1个值为e的结点\nDoublyLinkedList *Locate(DoublyLinkedList *head, ElemType e);\n//3. 在双向链表中查找第i个结点，返回指向该结点的指针\nDoublyLinkedList *GetElemP(DoublyLinkedList *head,int i);\n//4.在双向链表第i个结点之前插入元素e\nint InsertElem(DoublyLinkedList *head,int i,ElemType e);\n//5. 在双向链表中删除第i个结点，并返回结点的元素值\nint DeleteNode(DoublyLinkedList *head,int i,ElemType *e);\n46",
    "1. 创建长度为n的双向链表\nDoublyLinkedList *CreateDoublyLinkedList(int n){\nDoublyLinkedList *head,*p,*s; int i;\n//创建头结点\np=head=(DoublyLinkedList *)malloc(sizeof(DoublyLinkedList));\nfor(i=1;i<=n;i++){\n    s=(DoublyLinkedList *) malloc(sizeof(DoublyLinkedList));\n    scanf(\"%d\",&s->data);\n    s->prior=p; p->next=s; p=s;\n    }\np->next= NULL; head->prior = NULL;\nreturn head;\n}\n47",
    "2. 在双向链表中查找第1个值为e的结点\nDoublyLinkedList *Locate(DoublyLinkedList *head,ElemType e) {\nDoublyLinkedList *p;\np=head->next;  //p指向第一个结点\nwhile(p!=NULL  && p->data !=e)\n    p=p->next;\nreturn p;\n}\n关于链表为空的条件：双向循环链表与单链表是一样的\n48",
    "3. 在双向链表中查找第i个结点\n//返回指向第i个结点的指针\nDoublyLinkedList *GetElemP(DoublyLinkedList *head,int i) {\nDoublyLinkedList *p;int j;\nif(i<1) return NULL;\np=head->next; //初始化，p指向第一个结点\nj=1; //j为计数器\nwhile(p!=NULL  && j<i) {\n     //顺指针向后查找，直到p指向第i个结点或p为空\n    p=p->next; j++;}\nif(p==NULL) return NULL; // 第i个元素不存在\nreturn p;\n}\n49",
    "4. 在双向链表中插入元素e\n插入时若仅已知直接前驱结点p，拉链时必须注意先后次序\nS=(DoublyLinkedList *)malloc(sizeof(DoublyLinkedList)); \nS->data=e;\n(1) S->next=p->next;  (2) p->next->prior=S;\n(3) p->next=S;  (4) S->prior=p;    \n如果按(1)(3)，那么(2)要调整\n……\n……\n双向链表的插入\n(1)\n(2)\n(3)\n(4)\n50",
    "s->next = p->next;    p->next = s;\ns->next->prior = s;    s->prior = p;\np\ns\n插入：需要同时修改两个方向上的指针",
    "在双向链表中插入元素e\n插入时同时给出直接前驱结点p和直接后继结点q，那么，钩链时无须注意先后次序\nS=(DoublyLinkedList *)malloc(sizeof(DoublyLinkedList));\nS->data=e;\np->next=S;       S->next=q;\nS->prior=p;      q->prior=S;\n……\n……\n……\n……\n双向链表的插入\n52",
    "4.在双向链表第i个结点之前插入元素e\nint InsertElem(DoublyLinkedList *head,int i,ElemType e){\nDoublyLinkedList *p,*q;int j;\nif(i<1) return 0; // i的合法值为1≤i≤表长+1 \np=head; j=0;\nwhile(p!=NULL  &&j<i-1){ //在L中确定第i-1个元素的位置指针p \n    p=p->next;j++;\n}\nif(p==NULL) return 0; // i值过大，第i个元素不存在\nq=(DoublyLinkedList *)malloc(sizeof(DoublyLinkedList));\nq->data=e;\nq->next=p->next; \nq->prior=p;\nIf(p->next!=NULL) p->next->prior=q;   \np->next=q;\nreturn 1;\n}\n2.18\n53",
    "5. 在双向链表中删除第i个元素\n与单链表的插入和删除操作不同的是，在双向链表中插入和删除必须同时修改两个方向上的指针域的指向\n若p指向要被删除的结点\np->prior->next=p->next;\np->next->prior=p->prior;\nfree(p);\np\n54",
    "删除：需要同时修改两个方向上的指针\np->next = p->next->next;\np->next->prior = p;\np\n删除ai元素所在的结点，p指向被删除结点的前驱",
    "5. 在双向链表中删除第i个结点\n// 当第i个结点存在时，删除它并返回其值，否则返回NULL \nint DeleteNode(DoublyLinkedList *head, int i, ElemType *e){\nDoublyLinkedList *p,*q; int j; \nif(i<1) return 0; \np=head->next; j=1; // p指向第一个结点\nwhile(p != NULL && j<i){\n\t//顺指针向后查找，直到p指向第i个结点或p为空\n\t p=p->next; j++;}\nif(p ==NULL) return 0; // 第i个结点不存在\np->prior->next=p->next;\nIf(p->next!=NULL) p->next->prior=p->prior;\n*e=p->data;\nfree(p);\nreturn 1;\n}\n56",
    "5. 在双向链表中删除第i个结点\nint DeleteNode(DoublyLinkedList *head, int i, ElemType *e) { \nDoublyLinkedList *p; \n//在head中确定第i个结点的位置指针p \np=GetElemP(head,i);\nif(!p) return 0; //第i个结点不存在 \n*e=p->data;\np->prior->next=p->next;\nif(p->next != NULL) p->next->prior=p->prior;\nfree(p);\nreturn 1;\n}\n2.19\n57",
    "3.4 循环链表(Circular Linked List)\n单链的循环链表：每一个结点只包含一个指向直接后继的指针域，但其最后一个结点的指针域指向链表的头结点，整个链表的指针域链接成一个环\n对于单循环链表，除链表的合并外，其它的操作和单线性链表基本上一致，仅仅需要在单线性链表操作算法基础上作以下简单修改：\n判断是否是空链表：head->next==head\n判断是否是表尾结点：p->next==head\n58",
    "循环链表的操作\n设置头指针、尾指针的循环链表\n例如：两个循环链表La、Lb合并成La\n设La、Lb的尾指针分别为A、B\n\n\n\n\n\n仅设置尾指针的循环链表\n… …\n… …\nA\nB\n(1) A->next=Lb->next;\n(2) B->next=La;\nLa\nLb\n(3) A=B\n59",
    "双向循环链表\n具有指向前驱和后继的指针，这样，从循环链表的任意一个结点出发都可以找到链表中的其它结点，使得表处理更加方便灵活\n空表\n非空表\na1        a2    … ...     an\n60",
    "线性表链式存储方式的比较",
    "线性表链式存储方式的比较\n现有应用，其主要的操作是 找表首结点、找表尾结点和找P结点的前驱结点，试问，用哪个数据结构比较好？\n（1）带头结点的单链表\n（2）带头结点的循环单链表\n（3）带尾指针的循环单链表\n（4）带头结点的双向循环链表\n62",
    "总结\n了解线性表的定义、基本操作\n掌握线性表的存储结构及操作实现\n顺序存储结构\n链式存储结构\n会根据需求，设计、应用线性表\n63"
  ],
  "Chapter+3-栈和队列-Part+1栈": [
    "第三章 栈和队列\nPart I-栈",
    "目录\n栈\n栈的基本概念\n顺序栈\n链式栈\n栈的应用举例\n队列\n队列的基本概念\n队列的具体实现\n队列的应用举例\n栈和队列是操作受限的线性表，应用广泛\n1",
    "1. 栈的基本概念\n栈(Stack)是限制在线性表的一端进行插入和删除操作的线性表，也称为后进先出(LIFO,  Last In First Out)或先进后出(FILO, First In Last Out)线性表\n栈顶(Top)：允许进行插入、删除操作的一端，也称为表尾。用栈顶指针来指示栈顶元素\n栈底(Bottom/Base)：固定端，也称为表头\n空栈：当表中没有元素时称为空栈\n2",
    "栈的示意图\n设栈S=(a1, a2, …, an)，则a1称为栈底元素，an为栈顶元素\n栈中元素按a1，a2，…an的次序进栈，出栈的第一个元素应为栈顶元素，即栈的修改是按后进先出的原则进行的\n3",
    "栈的特性\n4",
    "栈的设计\n栈顶，可以用一个指针指向或找到栈顶元素\n栈底，可以用一个指针指向或找到栈底元素\n栈的大小：栈占据的空间\n\n初始化栈(构造一个空栈)\n销毁栈\n判断栈是否为空\n返回栈的长度(即元素个数)\n(Push)元素进栈，成为栈顶元素\n(Pop)栈顶元素出栈，并返回其值\n取栈顶元素， 但并不在栈里删除该元素\n从栈底到栈顶依次对栈的每个元素调用visit()\n5",
    "栈的具体实现\n顺序栈，也就是栈的顺序存储结构\n和线性表相类似，用一维数组来存储栈\n根据数组是否可以根据需要增大，又可分为：\n动态顺序栈\n静态顺序栈\n\n链式栈\n6",
    "2. 顺序栈\n动态顺序栈：采用动态一维数组来存储栈\n所谓动态指的是栈的大小可以根据需要增加\n用base表示栈底指针，栈底固定不变的\n栈顶则随着进栈和退栈操作而变化，用top(称为栈顶指针)指向数组中的下一个空闲存储位置\n用top==base作为栈空的标记\n7",
    "数据元素进出栈\n进栈：首先将数据元素保存到栈顶(top所指的当前位置)，然后，执行top加1，使top指向栈顶的下一个存储位置\n出栈：首先执行top减1，使top指向栈顶元素的存储位置，然后将栈顶元素取出\n8",
    "动态顺序栈\n#define INITSIZE 100  //栈空间初始分配量\n#define INCREMENTSIZE 10  //栈空间分配增量\n\ntypedef  int  ElemType ;\ntypedef struct { \n    \tint top;    // 栈顶指针  \n\tElemType  *base;  // 栈不存在时值为NULL     \n\tint   stacksize ;        // 当前已分配空间\n}SqStack ;\n9",
    "动态顺序栈的基本操作\n//1. 构造一个空栈S\nStatus InitStack(SqStack *s);\n//2. 取栈的长度\nint GetLen(SqStack *s);\n//3. 查看栈顶元素\nStatus GetTop(SqStack *s, ElemType *e);\n//4. 元素入栈\nStatus Push(SqStack *s,ElemType e);\n//5. (栈顶)元素出栈\nStatus Pop(SqStack *s,ElemType *e);\n//6. 判断栈是否为空\nint IsStackEmpty(SqStack *s);\n//7. 遍历栈，从栈顶到栈底依次对每个元素调用visit()\nStatus StackTraverse(SqStack *s, visit());\n10",
    "动态顺序栈的基本操作-1, 2, 3\nStatus InitStack(SqStack *s){//构造一个空栈s\n    s->base=(ElemType *)malloc(INITSIZE * sizeof(ElemType));\n    if (!s) return ERROR;\n    s->stacksize=INITSIZE;\n    s->top=0;\n    return OK;\n}\n\nint GetLen(SqStack *s){\nreturn (s->top);\n}\n\nStatus GetTop(SqStack *s,ElemType *e) { //只查看，不修改栈\nif(s->top==0) return ERROR; // 栈空，返回出错标志\n*e=s->base[s->top-1];\nreturn OK; }\n11",
    "动态顺序栈的基本操作-4,5\nStatus Push(SqStack *s,ElemType e){\nif(s->top >= s->stacksize) { \n    //若栈已满，则增加INCREMENTSIZE个存储单元\n    s->base=(ElemType *)realloc(s->base,(s->stacksize + \tINCREMENTSIZE)*sizeof(ElemType));\n    if(!s->base) return ERROR;\n    s->stacksize+=INCREMENTSIZE;\n}\ns->base[s->top++]=e;  //e成为新的栈顶元素，栈顶指针加1\n\t\t         // 等于s->base[s->top]=e; s->top++；\nreturn OK;\n}\n\nStatus Pop(SqStack *s,ElemType *e) {\nif(s->top==0) return ERROR; //栈空，返回出错标志\n*e=s->base[--s->top]; // 等于s->top--; *e=s->base[s->top]; \nreturn OK;\n}\n12",
    "动态顺序栈的基本操作-6,7\nint IsStackEmpty(SqStack *s)\n{\n    if(s->top == 0) return 1;\n    else return 0;\n}\n\nStatus StackTraverse(SqStack *s, void visit(ElemType *e))\n { int i;\nif(s->top==0) return ERROR;\nfor(i=s->top-1;i>=0;i--)\n    visit(&s->base[i]);\nreturn OK;\n}\n13",
    "例：数制转换\n给定十进制整数N和进制d，实现从十进制整数向其他进制转换\n转换法则：N =(N div d)*d + N mod d\n其中：div为整除运算，mod为求余运算\n例如： (1348)10= (2504)8，其运算过程如下：\n            N         N div 8     N mod 8\n          1348       168             4\n            168        21              0\n             21         2                5\n              2           0               2\n14\n计算顺序\n输出顺序\n将余数逐一进栈",
    "数制转换：采用动态顺序栈\nvoid Conversion(int n,int d) { \n//将十进制整数n转换为d进制数\nElemType e;\nSqStack s;  if(!InitStack(&s)) return;\nwhile(n!=0) { //将余数逐一进栈\n    Push(&s, n%d);\n    n=n/d;\n    }\nwhile(!IsStackEmpty(&s)) {\n    Pop(&s,&e); printf(\"%d \",e);\n    }\n}\n15\n3.1",
    "例：括号匹配问题\n在文字处理软件或编译程序设计时，常常需要检查一个字符串或一个表达式中的括号是否相匹配\n假设表达式中仅允许两种括号即圆括号、方括号，那么，下列是正确的括号序列：\n([]())\n[( [] [])]\n下列是不正确的括号序列：\n[(])\n([()] \n(( )])\n16",
    "检查括号是否匹配\n匹配思想：从左至右扫描一个字符串(或表达式)，每遇到一个右括号，将把它与最近遇到的那个左括号相匹配\n举例：\n\t[  (   [   ]  [   ]   )  ]\n\t1  2  3 4  5  6  7  8\n分析可能出现的匹配失败情况\n到来的右括弧不能与左括号匹配\n直到结束，也没有所期待的右括弧到达\n17",
    "算法思想\n设置一个栈，当读到左括号时，将它进栈\n当读到右括号时，\n若栈空，则该括号多余，返回ERROR，\n否则，与栈顶元素(左括号)进行匹配，\n若匹配成功，从栈顶删除该左括号，继续读入\n否则，匹配失败，返回ERROR\n算法的终止条件\n输入结束的时候，栈为空，则终止，返回OK\n输入结束的时候，栈不为空，则终止，返回ERROR\n读到的右括号与栈顶的左括号不匹配或栈空，则终止，返回ERROR\n18",
    "Status MatchingBrackets(char *exps) {\nint i=0; Status state=OK; ElemType e; SqStack s; InitStack(&s);\nwhile(state && exps[i]!=‘\\0’ ) { //输入未结束\n    switch(exps[i]) {\n\tcase '(':\n\tcase '[':\n\tcase '{':Push(&s,exps[i]); break;\n\tcase ')':\n\tcase ']':\n\tcase '}':if(!GetTop(&s,&e)) {state=ERROR; break;};\n        \t             if((e=='(' && exps[i]==')') ||  (e=='[' && exps[i]==']') ||  \n\t\t\t(e=='{' && exps[i]=='}'))\n\t\tPop(&s,&e);\n\t            else state=ERROR;\n\t            break;\n\t}\n    i++;\n}\nif(IsStackEmpty(&s) && state) return OK; \nelse return ERROR; }\n19",
    "静态顺序栈\n采用静态一维数组来存储栈\n栈底固定不变的，而栈顶则随着进栈和退栈操作变化的\n用一个整型变量top(称为栈顶指针)指向当前栈顶位置\n用top=0表示栈空的初始状态，\n用top指向栈顶元素在数组中的存储位置\n若栈的数组有Maxsize个元素，则top=Maxsize-1时栈满\n\n#define  MAX_STACK_SIZE  100  //栈的大小 \ntypedef  int  ElemType ;\ntypedef struct {\n\tint  top;\n\tElemType   stack_array[MAX_STACK_SIZE];\n  } SqStack;\n20",
    "数据元素进出栈\n进栈：先执行top加1，使top指向新的栈顶位置，然后将数据元素保存到栈顶(top所指的当前位置)\n出栈：先把top指向的栈顶元素取出，然后执行top减1，使top指向新的栈顶位置\n21",
    "3. 链式栈\ntypedef struct Node{\n    ElemType data;\n    struct Node *next;\n} LinkedStack;\nLinkedStack *InitStack(void);\nint GetLen(LinkedStack *s);\nStatus GetTop(LinkedStack *s,ElemType *e);\nStatus Push(LinkedStack *s,ElemType e);\nStatus Pop(LinkedStack *s,ElemType *e);\nint IsStackEmpty(LinkedStack *s);\n栈顶指针就是链表的头指针\n没有设置用于记录栈的长度/栈元素个数的变量",
    "//创建一个带头结点的空栈\nLinkedStack *InitStack(void){ \nLinkedStack *s;\ns=(LinkedStack *)malloc(sizeof(LinkedStack));\ns->next=NULL;\nreturn s;\n}\n\nint GetLen(LinkedStack *s){\nint i=0; LinkedStack *p; p=s->next;\nwhile(p){\n    i++;p =p->next;\n    }\nreturn i;\n}\n23",
    "Status Push(LinkedStack *s,ElemType e){\nLinkedStack *p;\np=(LinkedStack *)malloc(sizeof(LinkedStack));\nif(!p) return ERROR;\np->data = e; \np->next=s->next; //新结点插入到头结点之后\ns->next=p;\nreturn OK;\n}\n\nStatus Pop(LinkedStack *s,ElemType *e){\nLinkedStack *p;\nif(!s->next) return ERROR;\np=s->next;\n*e=p->data; //取栈顶元素\ns->next=p->next; // 修改栈顶指针\nfree(p);\nreturn OK; }\n24",
    "例：行编辑程序问题\n在用户输入一行的过程中，允许用户输入出差错，并在发现有误时可以及时更正\n假设“#”为退格符，“@”为退行符，那么从终端接收了这样两行字符：\n        whli##ilr#e (s#*s)\n        outcha@putchar(*s=#++);\n实际有效的是下列两行：\n        while (*s)\n        putchar(*s++);\n如何实现？\n设立一个栈结构的输入缓冲区，用以接收用户输入的一行字符\n25",
    "LinkedStack *s; s=InitStack();\nElemType c; char ch;\nch=getchar();\nwhile(ch!=EOF) {\n    while(ch!=EOF && ch !='\\n'){\n        switch(ch){\n        case '#':if(!Pop(s,&c)) return 1; break;\n        case '@': ClearStack(s);break;\n        default: if(!Push(s,ch)) return 1; break;}\n    ch=getchar();\n    }\n//打印出从栈底到栈顶的字符，并置s为空栈\nPrintStack(s); \nif(ch!=EOF) ch=getchar();\n}\nreturn 0;\n26\n3.2\nCtrl + Z",
    "void PrintStack(LinkedStack *s){\nLinkedStack *t,*p;\nElemType e;\nint i,j; \ni=GetLen(s);j=1; t=InitStack(); \nwhile(j<=i){\n    Pop(s,&e);Push(t,e);j++;}\np=t->next;\nwhile(p!=NULL) {\n    printf(\"%s\",p->data);\n    p=p->next;\n    }\nprintf(\"\\n\");\n}\n27",
    "4. 栈的应用举例\n算术表达式求值/中缀表达式求值\n后缀表达式求值\n迷宫寻路\n递归的实现\n28",
    "例：四则运算/算术表达式求值\n操作数\n浮点数\n运算符和界限符\n+，-，*，/，\n(，)，\n#(表达式结束符)\n四则运算规则：\n先乘除，后加减(棕色)\n同级运算顺序从左算到右(蓝色)\n先算括号内，后括号外(红色)\n上述运算规则总结成按算符之间的优先级进行计算\n设θ1，θ2 相继出现，θ1<θ2：表示θ1优先级低\n29",
    "算术表达式求值：算符优先法\n设置两个工作栈\nOPTR栈，用于存放算符，栈底元素设置为#\nOPND栈，用于存放操作数和运算结果，初始为空\n依次读入表达式的每个字符\n若是操作数，则进OPND栈\n若是算符，则与OPTR栈的栈顶算符进行优先级比较，然后进行相应操作\n直到表达式求值完毕(即OPTR栈顶元素和当前读入字符均为#)\n30",
    "例如：2*3+4*5#\n31\nOPTR\nOPND\n#\n*\n*\n3\n2\n4\n6\n6\n6\n6\n26\n4\n5\n20\n#\n#\n#\n#\n#\n#\n+\n+\n+\n+\n#\n#\n#\n*\n+\n*\n+",
    "// 引入算符优先级矩阵\n#define OPSETSIZE 7 \nchar OPSET[OPSETSIZE]={'+' , '-' , '*' , '/' ,'(' , ')' , '#'}; \nunsigned char Prior[OPSETSIZE][OPSETSIZE] = { \n {'>','>','<','<','<','>','>'},\n {'>','>','<','<','<','>','>'},\n {'>','>','>','>','<','>','>'},\n {'>','>','>','>','<','>','>'},\n {'<','<','<','<','<','=',' '},\n {'>','>','>','>',' ','>','>'}, \n{'<','<','<','<','<',' ','=' }};\n32\n3.4",
    "//测试Test是否是算符\nStatus In(char Test, char* TestOp)\n{\nfor (int i=0; i< OPSETSIZE; i++) { \nif (Test == TestOp[i]) \n\treturn OK; }\n return ERROR; } \n\n//执行四则运算：a theta b\nfloat Operate(float a, unsigned char theta, float b) {\nswitch(theta) { \ncase '+': return a+b; \ncase '-': return a-b; \ncase '*': return a*b; \ncase '/': return a/b; \ndefault : return 0; } \n}\nint ReturnOpOrd(char op, char* TestOp) { \nfor(int i=0; i< OPSETSIZE; i++) { \nif (op == TestOp[i]) \nreturn i; } \nreturn 0;\n}\n\u000b//返回两算符之间的优先关系\nchar precede(char Aop, char Bop){ \nreturn Prior[ReturnOpOrd(Aop,OPSET)][ReturnOpOrd(Bop,OPSET)]; \n}\n33",
    "float EvaluateExpression(char* MyExpression) {\nSqStack OPTR,OPND;\n//StackChar OPTR;  // 算符栈//StackFloat OPND; // 运算数栈，\nchar TempData[20]; strcpy(TempData,\"\\0\"); \nfloat Data,a,b;  char theta,*c, x, Dr[2]; \nInitStack (OPTR); Push (OPTR, '#'); \nInitStack (OPND); c = MyExpression; \nwhile (*c!= '#' || GetTop(OPTR)!= '#') {\nif (!In(*c, OPSET)) {  // *c不是运算符则进 运算数栈\n… … \n} \nelse { // 根据它与算符栈 顶的优先关系，做相应的动作\nswitch (precede(GetTop(OPTR), *c)) {\n… …\n} // switch \n}\n} // while \nreturn GetTop(OPND);  }\n3.4\n34",
    "// 表达式当前字符*c不是运算符，则进运算数栈\nDr[0]=*c; Dr[1]='\\0'; strcat(TempData,Dr); c++; \nif(In(*c, OPSET)) { \nData=(float)atof(TempData); Push(OPND, Data); strcpy(TempData,\"\\0\"); \n}\n\n//*c 是运算符：\nswitch (precede(GetTop(OPTR), *c)) {\ncase ‘<’: //栈顶元素优先级低，则将读到的算符进栈 \nPush(OPTR, *c); c++; break; \ncase '=': // 脱括号并接收下一字符\nPop(OPTR, x); c++; break; \ncase ‘>’: // 栈顶算符出栈并将运算结果入 操作数栈\nPop(OPTR, theta); Pop(OPND, b); Pop(OPND, a); Push(OPND, Operate(a, theta, b)); break;\n}\n35",
    "实现问题\ntypedef union{float x; char op;} ElemType;\ntypedef struct {\n\tElemType *base;\n \tint top; //栈顶\n    \tint stacksize;\n}SqStack; // 动态顺序栈\n\nElemType tmp;\nchar theta;float a,b;\nPop(&OptrStack, &tmp); theta=tmp.op;\nPop(&OpndStack, &tmp);a=tmp.x;\nPop(&OpndStack, &tmp);b=tmp.x;\ntmp.x=Operate(a, theta, b);\nPush(&OpndStack,tmp);\n36",
    "表达式的不同表示\n仅限于二元运算符的表达式的部分BNF定义：\n表达式::=  操作数 运算符 操作数\n操作数::=  简单变量|表达式\n简单变量::= 标识符|无符号整数\n表达式Exp=S1 OP S2在计算机中的表示方法\n前缀表示法：OP S1 S2\n中缀表示法：S1 OP S2\n后缀表示法/逆波兰式(Reverse Polish Notation)：S1 S2 OP\nExp=a×b+(c-d/e)×f\n前缀式：+×ab×-c/def\n后缀式：ab×cde/-f×+\n37\n断点续讲",
    "表达式的不同表示\n表达式的三种表示方法\n操作数之间的相对次序不变，运算符的相对次序不同\n前缀式的运算规则为：连续出现的两个操作数和它们之前且紧靠它们的运算符构成一个最小表达式 // +×ab×-c/def\n后缀式的运算规则为：运算符在式中出现的顺序恰为表达式的运算顺序；每个运算符和它之前出现且紧靠它的两个操作数构成一个最小表达式  // ab×cde/-f×+\n后缀式求值：遇到操作数，进栈；遇到运算符，连续从栈中退出两个操作数，进行计算\n38\nExp=a×b+(c-d/e)×f",
    "将中缀表达式转换成后缀表达式\n实例分析\n中缀表达式：#a+b*(c-d)-e/f#\n后缀表达式：abcd-*+ef/-\n分析 中缀表达式 和 后缀表达式 中的运算符\n39\n#\n+\n*\n(\n-\n-\n)\n/\n-\n#\na\nb\nc\nd\n-\n*\n+\ne\nf\n/\n-",
    "将中缀表达式转换成后缀表达式\n设表达式的结束符为#。设立运算符栈，并将 #入栈。从中缀表达式读入一个字符ch\n重复以下步骤，直到 读入#且栈顶元素为#\n若ch是操作数，则直接输出，读下一个字符ch；\n若ch是运算符，比较ch的优先级和栈顶运算符的优先级： \n若ch的优先级高，则ch进栈，读下一个字符ch；\n若ch的优先级低，则栈顶运算符退栈并输出；\n若两者的优先级相等，则栈顶运算符退栈，若退出的是“(”，读下一个字符ch\n算法结束，输出序列为所需的后缀表达式\n40",
    "例：迷宫寻路/寻找从入口到出口的路\n通常用的是“穷举求解路径”的方法\n尝试不成功，沿原路退回\n用栈来保存从入口到当前位置的路径\n入口\n出口\n41",
    "迷宫路径算法的基本思想\n若当前位置“可通”，则纳入路径，继续前进\n若当前位置“不可通”，则后退，换方向继续探索\n若四周“均不通路”，则将当前位置从路径中删除出去\n如何表示迷宫？二维数组\n如何表示当前位置？数组下标：行，列\n迷宫的状态：数组元素值\n墙(X)，未走过(空格)，走过(*)，走不通(!)\n如何记录已经走过的路径？\n栈，二维数组的下标\n如何记录已探索过的路径？\n方向\n42",
    "\n\n\n\n\n\n\n\n\n\n\n\n\n1    1    1\n1    2    2\n2    2    2\n3    2    1\n3    3    1\n3    4    4\n2    4    1\n2    5    1\n2    6    4\n1    6    3\n1    5    3\n1    4    4\n3\n$\n$\n$\n$\n$\n$\n$\n$\n行，列，方向\n43",
    "设定当前位置的初值为入口位置；\n do｛\n   若当前位置可通，\n   则｛在迷宫标记该块被走过，将当前位置插入栈顶； \n           若该位置是出口位置，则算法结束；            \n           否则切换当前位置的东邻方块为新的当前位置；\n           ｝\n   否则 ｛//当前位置不通\n         若栈不空但栈顶位置的四周均不可通，\n\t\t则｛删去栈顶位置，并在迷宫标记该块“不通”；\n\t        \t若栈不空，则重新测试新的栈顶位置，\n        \t\t直至找到一个可通的相邻块或出栈至栈空；\n\t\t｝\n         若栈不空且栈顶位置尚有其他方向未被探索，则设定新的\n         当前位置为沿顺时针方向旋转找到的栈顶位置的下一相邻块；\n          ｝\n｝while (栈不空)；\n若栈空，则表明迷宫没有通路\n44",
    "typedef struct Maze { //表示迷宫\nchar array[10][10]; \n//迷宫的墙：X；没有走过的通道块：空格；\n//走过标记：*；走不通：!\n} MazeType;\ntypedef struct { //迷宫的坐标\nint r, c; //r 表示行，c表示列\n}PosType;\nTypedef struct { //表示路径中的一通道块\nint ord; //表示该通道块在路径上的序号 \nPosType seat; //通道块在迷宫中的坐标位置\nint di;//从此通道块走向下一个通道块的方向\n} ElemType; //保存在栈中的元素类型\nSqStack s; //记录从入口到当前位置的路径\n45",
    "// 判定迷宫的当前位置是否可通过(即未曾走到过的通道块)\nStatus Pass(MazeType MyMaze, PosType CurPos); \n\tStatus Pass( MazeType MyMaze,PosType CurPos) { \n\tif (MyMaze.arr[CurPos.r][CurPos.c]==' ') \n\t    return OK; // 如果当前位置是空格，则可以通过\n\telse return ERROR;    // 可能是墙，可能已经走过：\n\t\t// 包括当前的路径和被标记为走不通的通道块\n\t} \n//在迷宫的当前位置留下走过标记(*)\nvoid FootPrint(MazeType &MyMaze, PosType CurPos); \n\tvoid FootPrint(MazeType &MyMaze,PosType CurPos) { \n\tMyMaze.arr[CurPos.r][CurPos.c]='*'; } \n//在迷宫的当前位置留下走不通标记(!)\nvoid MarkPrint(MazeType &MyMaze, PosType CurPos); \n\tvoid MarkPrint(MazeType &MyMaze,PosType CurPos) { \n\tMyMaze.arr[CurPos.r][CurPos.c]='!'; }\n46",
    "//返回当前位置的Dir方向所指示的位置\u000bPosType NextPos(PosType CurPos, int Dir);\n      PosType NextPos(PosType CurPos, int Dir) { \n\tPosType ReturnPos; \n\tswitch (Dir) { \n\tcase 1: ReturnPos.r=CurPos.r; \t\t\t\tReturnPos.c=CurPos.c+1; break; \n\tcase 2: ReturnPos.r=CurPos.r+1; \t\t\t\tReturnPos.c=CurPos.c; break; \n\tcase 3: ReturnPos.r=CurPos.r; \t\t\t\tReturnPos.c=CurPos.c-1; break; \n\tcase 4: ReturnPos.r=CurPos.r-1; \t\t\t\tReturnPos.c=CurPos.c; break; \n            } \n\treturn ReturnPos; }\n47",
    "// 若迷宫maze中存在从入口 start到出口 end的通道，则求得一条通路存放在栈S中\nStatus MazePath(MazeType &maze, PosType start, PosType end, Stack &S) { \nPosType curpos; int curstep; ElemType e; \ncurpos = start; // 设定\"当前位置\"为\"入口位置\" \ncurstep = 1; // 探索第一步 \ndo { \nif (Pass(maze, curpos)) { // 当前位置可通过\n… … \n} \nelse { // 当前位置不能通过\n… … \n } // else \n} while (!StackEmpty(S) );\nreturn FALSE; } // MazePath\n3.3\n48",
    "// 当前通道块可通过\nFootPrint(maze,curpos); // 留下足迹 \ne.ord = curstep; e.seat= curpos; e.di =1;//从东开始 \nPush(S, e); // 将当前通道块加入路径 \nif (curpos.r == end.r && curpos.c==end.c) \nreturn (TRUE); // 到达出口\n//准备探索下一通道块\n//设置当前通道块为当前通道块的东邻\ncurpos = NextPos(curpos, 1); \ncurstep++;\n49",
    "// 当前位置不能通过\nif (!StackEmpty(S)) { \nPop(S,e); \nwhile (e.di==4 && !StackEmpty(S)) {\n// 留下不能通过的标记，并退回一步\nMarkPrint(maze,e.seat); Pop(S,e); \n } // while\nif (e.di<4) { \ne.di++; Push(S, e); // 换下一个方向探索\n// 当前位置设为新方向的相邻块\ncurpos = NextPos(e.seat, e.di); \n} // if \n} // if\n50\n能否找到最短路径？",
    "例：递归的实现\n栈的一个重要应用是在程序设计语言中实现递归调用\n编译器依靠“栈”来管理递归函数的调用\n\n递归调用：一个函数(或过程)直接或间接地调用自己本身，简称递归(Recursive)\n直接递归，间接递归\n尾递归：一个递归函数(或过程)中，递归调用语句是最后一条执行语句\n单向递归：指程序中的递归语句，在本程序操作执行前，都已经完成，如Fibonacci数列\n51",
    "递归举例：尾递归\n求阶乘函数 n!\nFactorial(n)  =  \n       1 \t\t          当n=0时\n       n*Factorial(n-1) 当n>0时\n\n\nint Factorial ( int n ) {\n    if ( n == 0 ) return 1;\n    else \n\treturn n*Factorial (n-1);\n}\n求单链表表尾的数据元素\nstruct  LNode {\n      ElemType      data;      // 数据域\n      struct Lnode   *next;  //指针域\n  }; \nLNode*  L;\n\nElemType FoundTail(LNode *L)\n{\n    if ( L->next == NULL )\n        return L.data;\n    else\n        return FoundTail(L->next);\n}\n52\n终止条件\n递推规则",
    "递归举例：不终止的递归函数\n为了使递归调用不至于无终止地进行下去，有效的递归调用函数(或过程)应包括两部分：\n递推规则(方法)\n终止条件\nint bad(int n) {\n    if ( n == 0)\n       return 0;\n    else\n       return  bad(n/3 + 1) + n-1;\n}\n\n初始输入 n = 10\nbad(10) ： bad(4) + 9\nbad(4) ： bad(2) + 3\nbad(2) ： bad(1) + 1\nbad(1) ： bad(1)\n53\n变量n永远不会变成0！\n永远不会执行基线情况！\n终止条件\n递推规则",
    "递归举例：求迷宫的路径\nStatus SeekPath(PosType curPos,PosType endPoint) {\n//从迷宫中坐标点curPos的位置寻找通向终点endPoint的路径\n//若找到则返回OK，否则返回ERROR\nif ((curPos.r==endPoint.r) && (curPos.c==endPoint.c)) return  OK;\nfor(int i=0; i<4; i++)  {\n    PosType pos = NextPos(curPos, i+1);\n    if (Pass(pos)) {\n       FootPrint(pos); // 留下足迹\n       if(SeekPath(pos, endPoint)){\n\tprintf(\"(%d %d)\", pos.r, pos.c);\n             return OK;\n            }\n        }\n} //for\nreturn ERROR;}\n54",
    "递归举例：汉诺塔(Tower of Hanoi)\n假设有三个分别命名为X、Y和Z的柱子，在柱子X上插有n个直径大小各不相同、从小到大编号分别为1, 2, …n的圆盘。现要求将X柱上的n个圆盘移至Z柱上并仍按同样顺序叠排，圆盘移动时必须遵循下列规则：\n每次只能移动一个圆盘\n圆盘可以插在X、Y和Z中的任一柱之上\n任何时刻都不能将一个较大的圆盘压在较小的圆盘之上\n55",
    "递归举例：汉诺塔\n算法思想：\n如果 n = 1，则将这一个盘子直接从X 柱移到Z 柱上\n否则，执行以下三步：\n用Z柱做过渡，将X 柱上的 (n-1) 个盘子移到 Y 柱上\n将X 柱上最后一个盘子直接移到Z 柱上\n用X 柱做过渡，将Y 柱上的 (n-1) 个盘子移到Z 柱上\n递归思想：将大问题化为规模小一些的同等问题来解决\n56",
    "int Count=0; //计数\nvoid move(char x, int n, char z) { \nprintf(\" %2i. Move disk %i from %c to %c\\n\", ++Count, n, x, z); }\n\n//将n个圆盘从x移动到z，y作为辅助塔\nvoid hanoi (int n, char x, char y, char z) {\nif (n==1) \n\tmove(x, 1, z); //将编号为1的圆盘从x移到z \nelse { \n\thanoi(n-1,x,z,y); \n\tmove(x, n, z); //将编号为n的圆盘从x移到z \n\t//将y上编号为1至n-1的圆盘移到z, x作辅助塔\n\thanoi(n-1, y, x, z); } \n}\n3.5\n时间复杂度？\n57",
    "时间复杂度计算\n基本操作：移动一次圆盘\n基本操作的频度：\nn个圆盘，需要f(n)次移动圆盘\n\nf(1) =1\nf(n) = 2*f(n-1) +1\n\nf(n)= 2n-1 *f(1) + Const\n汉诺塔：O(2n)，n是圆盘个数\n58",
    "递归算法\n思路\n把一个不能或不好直接求解的“大问题”转化成一个或几个“小问题”来解决，再把这些“小问题”进一步分解成更小的“小问题”来解决，如此分解，直至每个“小问题”都可以直接解决(此时分解到递归出口)\n递归分解要保证“大问题”与“小问题”相似，即，求解过程与环境都相似\n一旦遇到递归出口，分解过程结束，开始求值过程\n优点\n结构清晰，程序易读\n编写容易，因为编译程序代替用户完成了栈的管理\n正确性容易得到证明\n缺点\n往往比较耗时间耗空间。这是由于递归函数会不断进行函数的调用操作，而函数的调用是比较消耗资源的\n可将递归函数转化为非递归函数\n59",
    "递归实现：函数调用\n在一个函数的运行期间调用另一个函数时，在运行该被调用函数之前，需先完成三项任务：\n将所有的实参、返回地址等信息传递给被调用函数保存；\n为被调用函数的局部变量分配存储区；\n将控制转移到被调用函数的入口；\n从被调用函数返回调用函数之前，要完成下列三项任务：\n保存被调用函数的计算结果；\n释放被调用函数的数据区；\n依照被调函数保存的返回地址将控制转移到调用函数\n多个函数嵌套调用的规则是“后调用先返回”，用栈来完成上述任务\n60",
    "递归的实现\n递归函数的执行过程可视为同一函数进行嵌套调用\n调用层次\n递归工作栈：整个递归调用过程期间使用的数据存储区\n递归工作记录：每一层递归所需的信息(包括：实参、局部变量和上一层的返回地址)合成一个记录\n每进入一层递归，就产生一个新的工作记录压入栈顶；每退出一层递归，就从栈顶弹出一个工作记录\n当前活动记录：栈顶记录，指示当前层的执行情况\n当前环境指针：递归工作栈的栈顶指针\n61",
    "递归的实现\n从被调函数返回调用函数的一般步骤：\n若栈为空，则执行正常返回\n从栈顶弹出一个工作记录\n将“工作记录”中的参数值、局部变量值赋给相应的变量；读取返回地址\n将函数值赋给相应的变量\n转移到返回地址\n62",
    "递归工作栈\nmain()\n{ hanoi(3,a, b, c); return;}\n\nvoid hanoi (int n, char x, char y, char z ) \n{\nif (n==1)\n    move(x, 1, z); ;   \nelse {\n  hanoi(n-1, x, z, y); \n  move(x, n, z);     \n  hanoi(n-1, y, x, z); \n}\n}\n63\n盘子移动记录：第1次  1号盘  A---->C；\n第2次  2号盘  A---->B；第3次  1号盘  C---->B；\n第4次  3号盘  A---->C；第5次  1号盘  B---->A；第6次  2号盘  B---->C；第7次  1号盘  A---->C",
    "递归非递归转换\n对于尾递归和单向递归的算法，可用循环结构的算法替代\n利用栈模拟系统的运行，通过分析，只保存必要的信息，从而用非递归算法替代递归算法\n64\nint Factorial ( int n ) {\n    if ( n == 0 ) return 1;\n    else \n\treturn n*Factorial (n-1);\n}\nint Factorial ( int n ) {\nInt f=1,i;\nfor(i=2;i<=n;i++)\n\tf=f*n;\nreturn (f);\n}"
  ],
  "Chapter+3-栈和队列-Part+2队列": [
    "第三章 栈和队列\nPart II-队列\n1",
    "目录\n栈\n栈的基本概念\n顺序栈\n链式栈\n栈的应用举例\n队列\n队列的基本概念\n链队列\n顺序队列和循环队列\n队列的应用举例\n2",
    "1. 队列的基本概念\n与栈类似，队列(Queue) 也是运算受限的线性表\n只允许在表的一端进行插入，而在另一端进行删除 \n队头(front) ：允许进行删除的一端\n队尾(rear) ：允许进行插入的一端\n空队列：队列中没有元素\n特性：先进先出(First In First Out，FIFO)，先进入队列的成员总是先离开队列\n在空队列中依次加入元素a1, a2, …, an之后，a1是队头元素，an是队尾元素，而退出队列的次序只能是a1, a2, …, an\n3",
    "队列的设计\n队头(front)\n队尾(rear)\n\n创建一个空队列\n销毁已存在的队列\n将队列清为空队列\n判断是否为空队列\n返回队列的长度\n返回队列的队头元素 \n入队/Enqueue：向队列的队尾插入元素e\n出队/Dequeue：删除队头元素，并返回其值\n从队头到队尾依次对队列的每个数据元素调用函数visit()\n4",
    "2. 队列的链式表示和实现\n链队列：用链表表示的队列\n数据元素结点，设有头结点\n队列的队头指针和队尾指针\n\ntypedef struct Node {\n    \tElemType data;\n    \tstruct Node *next;\n} QNode;\ntypedef struct {\n\tQNode *front;\n\tQNode *rear;\n}LinkedQueue;\n5",
    "链队列的基本操作\n// 1. 链队列的初始化，构造一个空队列\nStatus InitQueue(LinkedQueue *lq);\n// 2. 取队列的长度\nint GetLen(LinkedQueue *lq);\n// 3. 判断队列是否为空\nint IsQueueEmpty(LinkedQueue *lq);\n// 4. 查看队头元素\nStatus GetFront(LinkedQueue *lq, ElemType *e);\n// 5. 元素入队(尾)\nStatus Enqueue(LinkedQueue *lq, ElemType e);\n//6. (队头)元素出队\nStatus Dequeue(LinkedQueue *lq, ElemType *e);\n6",
    "7\n链队列的操作实际上是单链表的操作，只不过是：\n删除在表头进行，\n插入在表尾进行，\n插入、删除时分别修改不同的指针\n如何判队列Q是否为空？\n队列会满吗？\n不会，因为删除队列结点时会释放结点空间\n除非内存不足\n头尾指针都指向头结点",
    "链队列的基本操作-1,3,4\n// 链队列的初始化，构造一个空队列(含头结点)\nStatus InitQueue(LinkedQueue *lq){\nlq->front=lq->rear=(QNode *)malloc(sizeof(QNode));\nif(!lq->front) return ERROR;\nlq->front->next=NULL;\nreturn OK;\n}\n\nint IsQueueEmpty(LinkedQueue *lq){\nif(lq->front == lq->rear) return 1;\nelse return 0;\n}\n\nStatus GetFront(LinkedQueue *lq,ElemType *e){\nif(lq->front == lq->rear)  return ERROR;\n*e=lq->front->next->data;\nreturn OK; }\n8",
    "链队列的基本操作-5\n// 入队：插入元素e为队列的新的队尾元素\nStatus Enqueue(LinkedQueue *lq,ElemType e){\nQNode *p;\np=(QNode *)malloc(sizeof(QNode));\nif(!p) return ERROR;\np->data =e; p->next=NULL;\nlq->rear->next=p; //修改尾指针\nlq->rear=p;\nreturn OK;\n}\n9\n∧\n∧",
    "链队列的基本操作-6\n//出队：若队列不空，则删除队列的队头元素，\n//用 e 返回其值，并返回OK；否则返回ERROR\nStatus Dequeue(LinkedQueue *lq, ElemType *e) {\nQNode *p;\nif (lq->front == lq->rear) return ERROR; \n\t\t    \t       //空队列的话，则出错\np = lq->front->next;  //p指向第一个结点\n*e = p->data;\nlq->front->next =p->next; //修改头结点的指针\nif(lq->rear==p) //删仅有的一个元素时，需修改尾指针\n\tlq->rear=lq->front; //删成了空队列\nfree(p);\nreturn OK;\n}\n10",
    "3. 队列的顺序表示和实现\n顺序队列：利用一组连续的存储单元(一维数组) 依次存放从队头到队尾的各个元素\n静态顺序队列的定义：\n#define MAXQUEUESIZE   100\ntypedef  struct  queue {\nElemType  Queue_array[MAXQUEUESIZE] ;\nint  queueSize; //队列空间的大小\nint  front; // 队头指针\nint  rear;  // 队尾指针\n}SqQueue;\n11",
    "静态顺序队列的基本操作\n在非空队列里，队头指针始终指向队头元素，而队尾指针始终指向队尾元素的下一位置\n初始化：front=rear=0\n判队列为空：front==rear\n判队列满：rear==MAXQUEUESIZE\n\n入队：将新元素插入rear所指的位置，然后rear加1 \n出队：删去front所指的元素，然后front加1并返回被删元素\n12",
    "静态顺序队列的假溢出\n队列的假溢出：数据元素入队会由于尾指针到达数组的上界而不能成功，但队列中实际元素个数可能远远小于数组大小\n假：指队列的实际可用空间并未占满\n原因：在入队和出队操作中，头、尾指针只增加不减小，致使被删除元素的空间永远无法重新利用\n13\nRealloc 不能解决假溢出问题",
    "循环队列(Circular Queue)\n循环队列：将为队列分配的向量空间看成为一个首尾相接的圆环\n在循环队列中进行出队、入队操作时，队头、队尾指针仍要加1\n但当队头、队尾指针到达MAXQUEUESIZE-1时，其加1操作的结果是指向0\n// i代表front或rear \nif  (i+1==MAXQUEUESIZE)   i=0;\nelse i++ ; \n这种循环意义下的加1操作可以用取模运算来实现\n14",
    "循环队列操作及指针变化情况\n进队：在队尾加元素，然后rear = (rear+1) % MAXQUEUESIZE\n出队：取队头元素，然后，front = (front+1) % MAXQUEUESIZE\n判断队空的条件：real == front\n15",
    "循环队列操作及指针变化情况\n判断队满的条件：\n队空和队满时，头尾指针均相等\n无法通过front==rear来判断队列“空”还是“满”\n解决方案：\n增加一个计数器，记录队列中的元素个数(即队列长度)\n增加一个标志位，区分队列是“空”还是“满”\n少用一个元素空间，约定：以“队列头指针在队尾指针的下一个位置上”为队满的标志\n16",
    "循环队列操作及指针变化情况\n判断队满的条件：\n(rear+1) % MAXQUEUESIZE == front\n数据元素入队前，测试尾指针在循环意义下加1后是否等于头指针，若相等则认为队满\n让rear所指的单元始终为空\n17\n(e)   正常情况",
    "循环队列的定义\n#define MAXQUEUESIZE   100\ntypedef  struct  queue {\nElemType *base;  // 动态分配的存储空间\nint  front; // 队头指针，\n\t\t //若队列不空，指向队头元素\nint  rear;  // 队尾指针，若队列不空，\n\t\t//指向队列尾元素 的下一个位置\n} CircularQueue;\n18",
    "循环队列的基本操作\n// 1. 链队列的初始化，构造一个空队列\nStatus InitQueue(CircularQueue *cq);\n// 2. 取队列的长度\nint GetLen(CircularQueue *cq);\n// 3. 判断队列是否为空\nint IsQueueEmpty(CircularQueue *cq);\n// 4. 查看队头元素\nStatus GetFront(CircularQueue *cq,ElemType *e);\n// 5. 元素入队(尾)\nStatus Enqueue(CircularQueue *cq,ElemType e);\n//6.  (队头)元素出队\nStatus Dequeue(CircularQueue *cq,ElemType *e);\n19",
    "循环队列的基本操作-1,2\n// 队列初始化，构造一个空循环队列 \nStatus InitQueue(CircularQueue *cq){\ncq->base = (ElemType *)malloc \t\t\t(MAXQUEUESIZE*sizeof(ElemType));\nif(!cq->base) return ERROR;\ncq->front=cq->rear=0;\nreturn OK;\n}\n\n// 返回队列的元素个数，即队列的长度\nint GetLen(CircularQueue *cq) {\nreturn ((cq->rear - cq->front + \t\t\t\tMAXQUEUESIZE)%MAXQUEUESIZE);\n}\n20",
    "循环队列的基本操作-5,6\n// 插入元素e为Q的新的队尾元素\nStatus Enqueue(CircularQueue *cq,ElemType e) {\nif((cq->rear+1)%MAXQUEUESIZE == cq->front) return ERROR; //队列满\ncq->base[cq->rear]=e;\ncq->rear=(cq->rear+1)%MAXQUEUESIZE;\nreturn OK;\n}\n\n// 若队列不空，则删除Q的队头元素，\n// 用e返回其值，并返回OK;  否则返回ERROR\nStatus Dequeue(CircularQueue *cq,ElemType *e) {\nif(cq->front == cq->rear) return ERROR;\n*e=cq->base[cq->front];\ncq->front=(cq->front +1)%MAXQUEUESIZE;\nreturn OK;\n}\n21",
    "与队列有关的… …\n检测生活中的排队现象\n模拟生活中的排队 \n通过离散事件模拟\n申请资源的请求排队\n操作系统中的作业排队\n网络请求队列\nI/O请求队列\n消息队列中间件(Message Queue, Message oriented Middleware)\n排队论(Queuing Theory)\n22",
    "4. 队列的应用举例\n杨辉三角/二项式系数生成\n迷宫寻路  \n搜索问题，寻找从入口到出口的最短路径\n运动会日程安排 \n子集划分问题，将集合划分成无冲突的子集\n\n请求处理，资源的轮询调度(Round Robin Scheduling)\n离散事件模拟\n23\n断点续讲",
    "例：杨辉三角/Pascal's triangle/二项式系数生成\n设第n-1行有 i 个值，值分别为：\na[0]=0, \na[1],…a[i], \na[i+1]=0\n那么，第n行有i+1个值，\n值为B[j]=a[j-1]+a[j]，\nj=1,…,i+1\n\n如何利用队列生成？\n24\n杨辉三角：每个数字等于上一行的左右两个数字之和\n第n行的第i个数等于第n-1行的第i-1个数和第i个数之和\nC(n,i)=C(n-1,i)+C(n-1,i-1)",
    "杨辉三角\n25\n1\n1\n0\n1\n2\n1\n0\n1\n3\n3\n1\n0\n0\nC(n,i)= C(n-1,i-1) + C(n-1,i)",
    "生成total_row行的杨辉三角值\n//生成总共total_row行的杨辉三角值\nCircularQueue q; ElemType e; \nint r,total_row, cur_row_i_1=0, cur_row_i=0,next_row_i;\nInitQueue(&q); Enqueue(&q,1); Enqueue(&q,1);\nfor(r=1; r<total_row;r++){ //输出第r行，准备第r+1行数据\n    Enqueue(&q,0); //第r行的最后一个元素，也是第r+1行的开始\n    for(int c=1;c<=r+2;c++) {\n        Dequeue(&q,&e);\n        cur_row_i = e;\n        if (e) printf(\"%d \", cur_row_i);\n        next_row_i = cur_row_i + cur_row_i_1;\n        Enqueue(&q, next_row_i);\n        cur_row_i_1=cur_row_i;\n        }\n    printf(\"\\n\");\n} … //输出第total_row行\n26\n需要第10行的杨辉三角值，那么队列Q需要多长就足够了？",
    "例：迷宫寻路\n寻找从入口到出口的最短路径\n修改栈版迷宫算法\n利用队列针对迷宫进行广度优先搜索\n迷宫：用2维数组表示\n有待搜索的通道块：用队列表示\n轨迹(搜索过的块)：trajectories\n\ntypedef struct Node {\n    ElemType data;\n    struct Node *next;\n}QNode;\n\ntypedef struct {\n    QNode *front;\n    QNode *rear;\n}LinkedQueue;\nchar maze[10][10];\n//迷宫的墙：X；\n//没有走过的通道块：空格；\n//走过标记：*；路径：+\ntypedef struct{ //迷宫的坐标\n    int r,c; //r 表示行，c表示列\n} PosType;\n//表示路径中的一通道块\ntypedef struct{  \n     PosType seat;\n    //通道块在迷宫中的坐标位置\n    PosType former;      //从哪个块走过来的\n    int di; //从此通道块走向下一个通道块的方向\n} ElemType;\n\nElemType trajectories[1000]; \nint traP=0;\n27\n为什么广度优先搜索能获得最短路径？",
    "算法思想\n起始方块入队列Q；\nwhile (队列Q非空) {\n取Q的队头e；\n若e是终点，则 {\n\t从轨迹中回溯路径，\n\t打印路径，\n\t返回True}\n否则，将该方块记录到轨迹；\n依次取 e的下一步可以走到的方块s；\n如果 s是可通的方块 ，则 {\n\t则在该方块中记录该方块的前一个 位置，\n\t将该方块入队，\n\t将该点设置为走过// FootPrint(s)；\n       }\n}\n返回False //没有到达目的地的路径\n28",
    "例：运动会日程安排\n某运动会设立 n 个比赛项目，每个运动员可以参加一至三个项目。试问如何安排比赛日程可以使同一运动员参加的项目不安排在同一单位时间进行\n某运动会设有 9 个项目：\n    A = { 0，1，2，3，4，5，6，7，8 }\n运动会n 个比赛项目构成一个大小为 n 的集合A\n7名运动员报名参加的项目分别为：\n（1，4，8）,（1，7）,（8，3）,\n（1，0，5）,（3，4）,（5，6，2）,（6，4）\n问：哪些项目可以同时进行？\n把集合A划分成互不相交的子集，同一子集的项目为可以同时进行的项目\n29",
    "运动会日程安排\n有同一运动员参加的项目抽象为“冲突”关系\n项目之间的冲突关系为: R = \n{（1，4）,（4，8）,（1，8）,（1，7）,（8，3）,（1，0）,（0，5）,（1，5）,（3，4）,（5，6）,（5，2）,（6，2）,（6，4）} \n\n子集划分问题：将n个元素组成的集合A划分成k个互不相交的子集A1，A2，…，Ak (k≤n)，使同一子集中的元素均无冲突关系\n30\nk事先未知",
    "运动会日程安排\n31\n0\n1\n2\n3\n4\n5\n6\n7\n8\n运动项目\n分组组别\nA\n1\nA\nA\n4\n5\n6\nA\n8\n冲突的项目： （1,4）,（4,8）,（1,8）,（1,7）,（8,3）,（1,0）,（0,5）,（1,5）,（3,4）,（5,6）,（5,2）,（6,2）,（6,4）\n矩阵\n数组\n队列\n初始项目怎么选？",
    "互不相交的子集划分\n数据结构：\n设集合共有n个元素\n用队列sq存放集合元素\n用矩阵conflictMatrix[n][n]表示元素之间的冲突关系：\nconflictMatrix[i][j]=1, 如果i,j有冲突\nconflictMatrix[i][j]=0, 如果i,j无冲突\n用数组result[n]存放每个元素的子集/分组编号\n算法思想：利用循环筛选：\n从第一个元素开始，无冲突的元素划归为一个子集；\n再将剩下的元素重新找出互不冲突的元素，划归第二个子集\n依次类推，直到所有元素都进入某个子集为止\n32",
    "数据结构改进\n用工作数组clash[n]记录与第k组已入组元素有冲突的元素情况(当组号为k时)\n每次新开辟一组时，令clash数组各分量的值均为0，当序号为 head 的元素入组时，将和该元素发生冲突的信息记入clash 数组\nclash的引入可以减少重复察看conflictMatrix数组的时间\n33",
    "0    1    0    0    0      1    0    0    0\n0    1    0    0    0     2    1    0    0\n0    1    0    0    1     2    1    0    1\n0    2    0    0    1     2    1    0    1\n34\n集合划分结果：\n第1组: 0237\n第2组: 16\n第3组: 45\n第4组: 8\n队列元素情况：",
    "算法流程\n初始化队列；全体集合元素入队列；\n取队头元素，组号为1，clash的值被设置为队头元素在矩阵中的行值；\nWhile(队列不空) {\n  取队头元素x；\n  若它与当前组的元素没有冲突，即Clash[x]==0 {\n      在result中设置该元素对应的分组号；\n      修改clash记录 (即，在原clash记录之上叠加上该元素的\n      冲突情况)\n      }\n  否则，将x再次入队\n  判断是否走完一轮 (即，若当前队列的队头的值小于前次\n  取的队头的值，那么 走完一轮)\n  若走完一轮，则：\n\t取队头元素x，组号加1，数组clash初始化为全0\n}\n35",
    "例：离散事件模拟\n事件驱动的模拟程序：模拟银行业务流程\n客户到达，客户排队等待，客户接受服务，客户离开\n不断地生成事件，不断地处理事件，两种交织在一起\n假设有4个客户接待窗口\n数据结构设计\n事件\n客户到达事件\n客户离开事件：4种，分别是从4个窗口离开\n事件表：按时间排序记录事件的有序表\n队列：4个客户排队的队列，客户到达后排到最短的队列\n操作流程设计\n处理客户到达事件：将客户排到当前最短的队，如排在队头，生成该客户离开事件；生成下一客户到达事件\n处理当前离开事件：删除相应队列头，之后，为当前队列的队头客户生成下一个的离开事件\n36",
    "离散事件模拟\n37\n事件列表\n客户到达事件？\n客户离开事件？\n客户出队列\n对非空队列，取队头，\n生成下一个客户离开事件\n客户入最短队列\n若排队头，\n生成客户离开事件\n生成下一个客户到达事件\n第一个客户\n到达事件\n按事件发生时刻的次序插入事件表",
    "数据结构\ntypedef struct {\n\tint OccurTime;  //事件发生时间\n\tint NType; \n\t//0表示到达事件，1-4表示从4个业务窗口的离开事件\n} Event, ElemType;\n\ntypedef  struct  LNode {\n \tElemType  data;     \n\tstruct   LNode  *next;\n} LNode, LinkList;\n\ntypedef LinkList EventList;\n38\ntypedef struct{\n    int ArrivalTime;     //客户到达时间\n    int Duration;  //办理事务所需时间\n} QElemType;\ntypedef struct Node {\n    QElemType data;\n    struct Node *next;\n} QNode;\ntypedef struct {\n    QNode *front;\n    QNode *rear;\n} LinkedQueue;\nEventList按事件发生时刻排列",
    "39\n运行示意图\nOccurTime\nNType",
    "全局变量和初始化\n#define CLOSETIME 100//关门时间\nEventList *ev; //事件列表 \nEvent en; \t//当前处理的事件 \nLinkedQueue q[5]; // 4个客户队列,q[0]未用 \nint ClientNum;//客户数\nint TotalTime; // 累计客户逗留时间 \n\nvoid OpenForDay() {\nTotalTime=0;ClientNum=0; \nev=InitList();\nen.NType=0;en.OccurTime=0; // 设定第一个客户到达事件\nOrderInsert(ev,en); //按事件发生时刻的次序插入事件表\nfor(int i=1;i<=4;i++)\n    InitQueue(&q[i]);\n}\n40",
    "主程序\nsrand((unsigned)time(NULL)); //随机数种子\nOpenForDay();\nwhile(!IsListEmpty(ev)) {\n    ListDelete_L(ev,1,&en);\n    if(en.NType ==0)\n        ClientArrived();// 处理客户到达事件\n    else ClientDeparture();// 处理客户离开事件\n }\n// 计算并输出平均逗留时间 \nprintf(\"Total time is %d, Client number is %d\\n, \nThe average time is %f\\n\", \nTotalTime, ClientNum, (float)TotalTime/ClientNum);\n41",
    "ClientArrived()/处理客户到达事件-I\n//生成下一客户到达事件，并插入事件列表\nEvent nClient; int nArrivalTime,intertime;\nClientNum++;\nintertime=rand()% 10;//间隔时间\n //设置下一个客户的到达时刻\nnArrivalTime=en.OccurTime+intertime; \nif(nArrivalTime < CLOSETIME){\n    // 银行尚未关门，插入事件列表\n    nClient.OccurTime = nArrivalTime;\n    nClient.NType=0;\n    OrderInsert(ev,nClient);\n}\n42",
    "ClientArrived()/处理客户到达事件-II\n//处理当前事件，将该事件放入最短队列\nQElemType qe; int durtime;\nint minno,minlen; //求最短队列，用minno标记\nminlen=GetLen(&q[1]);minno=1;\nfor(int i=2;i<=4;i++) {\n    if(minlen>GetLen(&q[i])) {minlen=GetLen(&q[i]);minno=i;}\n}\ndurtime=rand()% 300; //产生300以内的随机整数\nqe.ArrivalTime=en.OccurTime,\nqe.Duration=durtime; // 服务客户所需的时间\nEnqueue(&q[minno],qe);\nEvent lClient;\nif(GetLen(&q[minno])==1) { //若在队头，生成客户离开事件\n   lClient.NType=minno;lClient.OccurTime=en.OccurTime+durtime;\n   OrderInsert(ev,lClient);\n   }\n43",
    "ClientDeparture()/处理客户离开事件\nQElemType lc,nlc;\nEvent ne;\nint i=en.NType;\nDequeue(&q[i],&lc); //第i窗口的排头客户离开 \n// 累计客户逗留时间 \nTotalTime += en.OccurTime - lc.ArrivalTime;\nif(!IsQueueEmpty(&q[i])) {\n    // 取第i队列的队头，\n    GetFront(&q[i],&nlc);\n    ne.OccurTime=en.OccurTime+nlc.Duration;\n    ne.NType=i;\n    OrderInsert(ev,ne); //生成一个离开事件并插入事件表   }\n44",
    "例：请求处理\n服务请求处理：到达的请求排成队列，每次取队头，为之服务\n调度资源/分时服务：多个客户共享一个资源，如何使得资源使用兼顾公平和效率？循环为之服务\n\nRoundRobinScheduling() {\nInitQueue(Q); \n//将参与资源分配的客户组成队列 \nfor (int i=1;i<=n;i++) EnQueue(Q, client[i]);\nwhile (!ServiceClosed()){ //在服务关闭之前\n\tDeQueue(Q,c)//队头客户出队列\n\tServe(c);//接受服务\n\tEnQueue(Q, c); //重新入队\n\t}\n}\n45",
    "总结\n了解栈与队列的基本概念和特点\n掌握栈的存储结构(包括顺序栈、链式栈)及操作实现\n掌握栈满和栈空的条件以及它们的描述方法\n掌握队列的存储结构(包括链队列、顺序队列、循环队列)及操作实现\n掌握(循环队列)队满和队空的描述方法\n能在相应的应用问题中，正确地选用栈和队列\n46"
  ],
  "Chapter+4-串": [
    "第四章 串\n1",
    "目录\n串的基本概念\n串的具体实现\n顺序串/定长顺序存储：SString\n顺序串/堆分配存储： HString\n块链存储： LString\n串的模式匹配：KMP算法\n串操作应用举例\n2",
    "1. 串的基本概念\n串(即字符串，string)是由零个或多个字符组成的有限序列\n串是一类特殊的线性表\n其逻辑结构和线性表极为相似，区别仅在于表中每个数据元素是一个字符\n组成串的字符少，字符数量可以很大，对串的操作种类多且复杂\n串的基本操作和线性表有很大差别\n在线性表的基本操作中，大多以“单个元素”作为操作对象\n在串的基本操作中，通常以“串的整体”作为操作对象：在串中查找子串、插入子串、删除子串、替换子串\n3",
    "串\ns = “a1a2… an”, n>=0\n\n\n串的名：s\n串的值：双引号里的字符序列，但不包括双引号，双引号是定界符(delimiter)， ai可以是字母、数字和其他字符\n串的长度：串中字符的数目n\n字符在串中的位置：字符在串中的位序\n\n空串(null string)：零个字符的串，长度为0\nS=“”\n空格串(blank string)：由空格组成的串\nS=“    ”\n4\n隐含结束符‘\\0’ ，即ASCII码NUL\nx=“123”\t//x表示串\nx=123   \t\t// x表示整数\ns1=‘a’   \t //s1表示字符\ns2=“a” \t //s2表示字符串",
    "串\n子串：串中任意个连续的字符组成的子序列\n主串：包含子串的串\n子串在主串中的位置是以子串的第一个字符在主串中的位置来表示的\n空串是任意串的子串，任意串是其自身的子串\n平凡(trivial)子串 vs. 真(proper)子串：字符串自身之外的所有非空子串\n串的前缀：串中最靠前的若干个字符\n串的后缀：串中最靠后的若干个字符\n空串是任何串的前缀、后缀，任意串是其自身的前缀、后缀\n平凡前缀，平凡后缀，真前缀，真后缀\n串的相等：两个串相等当且仅当这两个串的值相等，即，两个串的长度相等，且对应位置的字符均相同\n字符相等意味着字符所对应的ASCII值相等\n5",
    "例\n现有如下字符串：\n\ta =“BEI” \tb =“JING”\n\tc = “BEIJING”     d = “BEI JING”\n这些串各自的长度？\n\ta =3，b =4，c = 7，d=8\nb是哪个串的子串？在主串中的位置是多少？\n\tb是c和d的子串\n\tb在c中的位置是4\n\tb在d中的位置是5\n6",
    "C语言中的串处理\n用字符数组存放串\nC语言<string.h>中的串处理函数\nchar *gets(char *str) ； //从stdin中读取串\nint puts(char *str) ； //向stdout输出串\nint strlen(char *str); //返回串的长度\nchar *strcpy(char *dest, char *src); //复制串\nchar *strcat(char *dest, char *src); //联接串\nint strcmp(char *str1, char *str2); //比较串，  s1<s2时返回负数，相等返回0，s1>s2时返回正数\nchar *strstr(char *str,char *substr); //返回子串首次出现的位置\n7\nC语言复习",
    "C语言函数库的串处理函数-部分\nstrchr：检索并返回字符c在字符串s中第一次出现的位置\nstrrchr：检索并返回字符串s中最后一次出现给定字符c的位置\nstrspn：检索并返回在s1和s2中均有的字符个数// string span \nstrpbrk：检索并返回两个字符串中首个相同字符的位置//string pointer break\n\nstrupr：将字符串s中的小写字母全部转换成大写字母，并返回转换后的字符串//upper\nstrlwr：将字符串s中的大写字母全部转换成小写字母，并返回转换后的字符串//lower\nstrtol：将字符串str转换成长整型数，并返回这个数\nstrtod：将字符串str转换成双精度数，并返回这个数\n8\nC语言复习",
    "C语言函数库的串处理函数-部分\nstrdup：将字符串s复制到新建的位置\nstrrev： 将字符串逆置\nstrtok：将字符串分割成由定界符隔离的一个个片段//string token\n\nstrncat：将字符串src中最多maxlen个字符复制到字符串dest中\nstrncmp：比较字符串s1与s2中的前maxlen个字符\nstrncpy：复制src中的前maxlen个字符到dest中\nstricmp：以不区分大小写的方式比较字符串s1和s2,并返回s1-s2 // case-insensitive\nstrnicmp：以不区分大小写的方式比较字符串s1与s2中的前maxlen个字符\n9\nC语言复习",
    "例：将串逆序保存\n//要求：不另设串存储空间\nvoid StrInvert (char *s)\n{ char tmp; static int i=0;\nint len;len=strlen(s);\nif(i<len/2){\n    tmp=s[i];\n    s[i]=s[len-i-1];\n    s[len-i-1] = tmp;\n    i++;\n    StrInvert (s);\n    }\n}\n10\n输入：Madam, I'm Adam\n输出：madA m’I, madaM",
    "串的设计\n基本操作\n加工型\n初始化串StrInit\n销毁串StrDestry\n清空串StrClear\n串赋值StrAssign\n串联接StrConcat\n取子串StrSubstr\n引用型\n求串长StrLen\n判串等IsStrEqual\n串比较StrComp\n其他操作\n加工型\n串插入StrInsert\n串删除 StrDelete\n串复制StrCopy\n串替换StrReplace\n引用型\n判是否空串IsStrEmpty\n串查找/串匹配StrIndex\n模式串是否在主串中出现\n模式串首次在哪里出现\n模式串分别出现在主串中的哪里\n模式串在主串中出现了几次\n11",
    "2.1 串：顺序串/定长顺序存储\n压缩存储：1个32位的内存单元存储4个字符\n串s = “Data structure”的串值连同结束符只需4个存储单元(4个字节为1个存储单元)\n\n    i\n    i+1\n    i+2\n    i+3\n\n非压缩储存：1个32位的内存单元存储1个字符\n#define MAXSTRLEN 255\nTypedef unsigned char SString[MAXSTRLEN+1];\n串的最大长度不能超过255\n如何标识串的实际长度？\n首字符存放串长度\n特殊字符(\\0)作为串结束符\n用变量存储实际长度\n\n按这种串的表示方法实现的串的运算时，其基本操作为 “字符序列的复制”，操作的时间复杂度基于复制的字符序列的长度\n12",
    "串拼接/将s1和 s2拼接成t\nint StrConcat(SString t,SString s1,SString s2){\nint uncut;\nif (s1[0]+s2[0] <= MAXSTRLEN) {\n    strncpy(&t[1],&s1[1],s1[0]);\n    strncpy(&t[s1[0]+1],&s2[1],s2[0]);\n    t[0]=s1[0]+s2[0];t[t[0]+1]='\\0'; uncut= TRUE;}\nelse if(s1[0]<MAXSTRLEN) {// s2被截断\n    strncpy(&t[1],&s1[1],s1[0]);\n    strncpy(&t[s1[0]+1],&s2[1],MAXSTRLEN-s1[0]);\n    t[0]=MAXSTRLEN;t[MAXSTRLEN+1]='\\0'; uncut=FALSE; }\n    else { //s1[0] >= MAXSTRLEN，故s2被截断，仅取s1\n    \tstrncpy(&t[1],&s1[1],MAXSTRLEN);\n    \tt[0]=MAXSTRLEN;t[MAXSTRLEN+1]='\\0';\n    \tuncut=FALSE; }\nreturn uncut;\n}\n13",
    "取子串/StrSubStr\n//将s中从第pos个字符开始的连续len个字符放到sub中\nStatus StrSubStr(SString sub,\n\t\t\tSString s,int pos,int len) {\n if(pos<1 || pos>s[0] || len <0 || \n\t\t\tlen > s[0]-pos+1) return ERROR;\n  strncpy(&sub[1],&s[pos],len);\n  sub[0]= len; sub[sub[0]+1]='\\0';\n  return OK; \n}\n14",
    "串匹配/int StrIndex(SString s, SString t, int pos)\n在主串s的第pos个字符之后寻找与t相等的子串，找到则返回第一个这样的子串在s中的位置，否则返回0\n例如：s= “abcaabcaaabc” , t=“bca”\nStrIndex(s,t,1)=2, StrIndex(s,t,3)=6, StrIndex(s,t,8)=0\n\n暴力求解(Brute-force)算法思想：\n将主串s的第pos个字符和模式t的第1个字符比较\n若相等，继续逐个比较后续字符；\n若不等，则从主串s的(pos+1)字符起，重新与t第1个字符比较。\n直到主串s的一个连续子串字符序列与模式t相等。返回值为s中与t匹配的子序列第一个字符的序号，即匹配成功，否则，匹配失败，返回值 0。\n15",
    "串匹配/模式匹配\nint StrIndex(SString s,SString t,int pos){\nint i,j; i=pos;j=1;\nwhile(i<=s[0] && j<=t[0]){\n    if(s[i] == t[j]) {i++;j++;} //继续比较后继字符\n    else {i=i-j+2;j=1;}\n    //指针i后退(至当前匹配起始位置的下一位置)\n    }\n    if(j>t[0]) //是否走完串t\n\treturn i-t[0]; \n\t//匹配成功，返回子串t在串s的位置\n    else return 0;\n}\n16",
    "s=“ababcabcacbab”, t=“abcac”, pos=1\u000bStrIndex(s,t,pos)返回值为6\n17\n第六趟匹配      a b a b c a b c a c b a b\ni=11\na b c a c",
    "暴力算法的时间复杂度\n令主串s的长度n，模式串t的长度m\n最好情况：只经过一轮比对，即可确定匹配，匹配次数 = m = O(m)\n最坏情况：每轮都比对到模式串的最后一个字符\n每轮循环，匹配次数 = m (前m-1次匹配，成功；最后一次失败)\n循环次数，n-m+1\n一般有m  << n，所以，总的匹配次数=m * (n-m+1) = O(n*m)\n最坏情况举例\n主串为 0000… 00001\n模式串为 0001\n18",
    "2.2 串：顺序串/堆分配存储\ntypedef struct {\n    char *ch;   //若是非空串，则按串长度+1分配存储区\n    int strsize; //存储空间大小，包含串的结束符\n   int length; //串长\n} HString; \n// 1.初始化串\nStatus StrInit (HString *s);\n// 2. 获取串的长度\nint StrLen(HString *s); \n// 3. 比较两个串是否相等\nStatus IsStrEqual(HString *s,HString *t);\n// 4. 比较两个串\nInt StrComp(HString *s,HString *t);\n19",
    "顺序串的基本操作\n//5. 将字符串常量sc赋给字符串变量s\nStatus StrAssign (HString *s,char *sc); \n//6. 将s1和 s2拼接成s\nStatus StrConcat (HString *s,HString *s1, HString *s2); \n//7. 取子串，将s中从第i个字符开始的连续j个字符放到subs\nStatus StrSubstr(HString *subs, HString *s,int i,int j); \n//8. 在s的第i个字符之前插入字符串t \nStatus StrInsert (HString *s,int i,HString *t); \n//9. 删除s的第i个字符开始的连续j个字符\nStatus StrDelete(HString *s,int i,int j); \n//10. 串替换，将s从第i个字符开始j个连续字符用字符串t替换\nStatus StrReplace (HString *s,int i,int j,HString *t); \n//11. 将字符串变量的值赋给字符串变量s\nStatus StrCopy(HString *s,HString *t);\n20",
    "HString的基本操作-1,2,3,4\nStatus StrInit(HString *s){\ns->ch = (char *)malloc(INITSTRLEN *sizeof(char));\nif(!s->ch) return ERROR;\ns->ch[0]='\\0'; s->length = 0; s->strsize= INITSTRLEN; return OK; }\n \nint StrLen(HString *s){ return s->length; }\n\nStatus IsStrEqual(HString *s1,HString *s2){ int i=0; \nfor(i=0;i<s1->length && i< s2->length; i++)\n    if(s1->ch[i]!= s2->ch[i]) return ERROR;\nif (i<s1->length || i<s2->length) return ERROR;\nelse return OK; }\n\n//s等于t，返回0；s大于t，返回值大于0；s小于t，返回值小于0\nint StrComp(HString *s,HString *t){\nfor(i=0;i<s->length && i<t->length;i++)\n    if(s->ch[i] !=t->ch[i]) return (s->ch[i]-t->ch[i]);\nreturn (s->length-t->length);\n}\n21",
    "HString的基本操作-5\n// 将字符串常量赋给字符串变量s\nStatus StrAssign(HString *s, char *sc){\nint i=0;\n//求sc的串长度i，串尾特征是sc[i]=‘\\0’\nwhile(sc[i]!=‘\\0’) i++; \nif(i>= s->strsize) {\n    s->ch =(char *)realloc(s->ch, (i+1)*sizeof(char));\n    if(!s->ch) return ERROR;\n    s->strsize = i+1; }\ns->length = i;\nfor(i=0;i<s->length;i++)\n    s->ch[i] = sc[i];\ns->ch[i]=‘\\0’;  //显式地补上串结束标志\nreturn OK;\n}\n22",
    "HString的基本操作-6\nStatus StrConcat(HString *s,HString *s1, HString *s2) {\n// 将s1,s2拼接成s\nint i;\nif(s->strsize < (s1->length + s2->length)) {\n    s->ch = (char *)realloc(s->ch, \n\t\t\t(s1->length+s2->length+1) * sizeof(char));\n    if(!s->ch) return ERROR;\n    s->strsize = s1->length + s2->length+1;\n    }\ni=0;\nwhile(i<s1->length) {s->ch[i]=s1->ch[i]; i++;} //拷贝s1串\nwhile(i<s1->length+s2->length) { \n\ts->ch[i]=s2->ch[i-s1->length]; i++;} //拷贝s2串\ns->ch[i]='\\0'; s->length = s1->length+s2->length;\nreturn OK; \n}\n23\nStrConcat(t, “pine”, “apple”)\nt = “pineapple”",
    "HString的基本操作-7\n// 取子串，将s中从第i个字符开始的连续j个字符放到subs\nStatus StrSubstr(HString *subs, HString *s, int i, int j){\nint k;\nif(i<=0 || i> s->length || j<0 || j > s->length -i +1) \n\treturn ERROR;\nif(subs->strsize < j) {\n    subs->ch =(char *) realloc(subs->ch,(j+1)*sizeof(char));\n    if(!subs->ch) return ERROR;\n    subs->strsize =j+1;\n}\nfor(k=0;k<j;k++) subs->ch[k] = s->ch[i-1+k];\nsubs->ch[j]='\\0';\nsubs->length=j;\nreturn OK;\n}\n24\nStrSubStr (sub, commander, 1, 9)\nsub=commander\nStrSubStr (sub, commander, 4, 0)\nsub = “”",
    "HString的基本操作-8\n//在s的第i个字符之前(1<=i<=s->length+1)插入字符串t\nStatus StrInsert(HString *s,int i,HString *t) { int j;\nif(i<=0 || i>s->length+1) return ERROR; // 位置不合法出错\nif(s->strsize < s->length + t->length){ //空间不够\n    s->ch = (char *)realloc(s->ch,\n\t\t\t(s->length+t->length+1)* sizeof(char));\n   if(!s->ch) return ERROR; \n    s->strsize = s->length + t->length; }\nfor(j=s->length-1;j>=i-1;j--) //字符后移，腾挪空间\n    s->ch[j+t->length] = s->ch[j];\nfor(j=0;j<t->length;j++) // 插入t\n    s->ch[i+j-1] = t->ch[j];\ns->length += t->length; \nreturn OK;\n}\n25\nStrInsert(“commander”,1,”xxx”)\n“xxxcommander”\nStrInsert(“xxxcommander”,6,”xxx”)\n“xxxcoxxxmmander”",
    "HString的基本操作-10\n//串替换，将s从第i个字符开始j个连续字符用字符串t替换\nStatus StrReplace(HString *s, int i, int j, HString *t){\nint k;\nif(i<=0 || i> s->length || j<=0 || j>s->length-i+1) return ERROR;\nif(j<t->length) {\n    if(s->length + t->length-j > s->strsize) {\n        s->ch =(char *) realloc(s->ch,(s->length+t->length-j+1)*sizeof(char));\n        if(!s->ch) return ERROR;\n        s->strsize = s->length + t->length –j+1;\n    }\n    for(k=s->length; k>=i+j-1;k--) //向后移，挪空间\n        s->ch[k-j+t->length] = s->ch[k];\n}\nelse \n for(k=i-1+j;k<s->length;k++) s->ch[k-j+t->length] = s->ch[k]; //向前移\ns->length = s->length + t->length -j; s->ch[s->length+1]='\\0';\nfor(k=0;k<t->length;k++)\n    s->ch[k+i-1] = t->ch[k];\nreturn OK;\n}\n26\nStrReplace(“commander”,1,2,”xxx”)\n“xxxmmander”\nStrReplace(“xxxmmander”,5,5,”xxx”)\n“xxxmxxxr”\nco被xxx替换\nmande被xxx替换",
    "顺序串的操作\n//模式匹配，在s的pos之后寻找与t相等的子串\nint StrIndex(HString *s, Hstring *t, int pos);\n\n//方法1：利用HString的基本操作实现\n//方法2：KMP算法\n\n//子串替换，用v替换主串s中出现的所有与t相等的不重叠的子串\nvoid StrRepSubstr(HString *s,HString *t,HString *v)\n//利用HString的基本操作实现\n27",
    "模式匹配：利用HString的基本操作\nint StrIndex(HString *s,HString *t, int pos)\n模式匹配：在主串s的第pos个字符之后寻找与 模式串t相等的子串，找到则返回第一个这样的子串在S中的位置，否则返回0\n假设 S = “abcaabcaaabc”,  T =“bca”,  \n那么：\nStrIndex(S, T, 1) = 2; \nStrIndex(S, T, 3) = 6; \nStrIndex(S, T, 8) = 0;\n28",
    "模式匹配\nint StrIndex(HString *s, HString *t, int pos){\nint i, m, n;\nHString sub; StrInit (&sub);\nif(pos > 0) {\n    i=pos; n=StrLen(s); m=StrLen(t);\n    while(i<=n-m+1) {\n        StrSubstr(&sub, s, i, m);\n        if(!IsStrEqual(&sub,t)) i++;\n        else return i;\n        }\n    }\nreturn 0;\n}\n29\nS 串(长n)\nT 串(长m)\npos\nn-m+1\nT 串(长m)",
    "子串置换：利用HString的基本操作\nvoid StrRepSubstr(HString *s,HString *t,HString *v)\n用v替换主串s中出现的所有与t相等的不重叠的子串\nn=StrLen(s); i=StrIndex(s,t,pos); m=StrLen(t);\n30\ns 串\nt串\nv 串\nv串\npos\npos\nsub\ni\nnewStr 串\nsub\n= i+m\npos\nn-m+1\n假设 s = abcaabcaaabca，\nt = bca，v = X，\ns = aXaXaaX",
    "子串置换\n//用v替换主串s中出现的所有与t相等的不重叠的子串\nvoid StrRepSubstr(HString *s,HString *t,HString *v){\nint n,m,pos,i;\nHString newStr,sub; StrInit(&newStr);StrInit(&sub);\nn=StrLen(s);m=StrLen(t);pos=1; i=1;\nwhile(pos<=n-m+1 && i) {\n    i=StrIndex(s,t,pos);\n    if(i!=0){\n        StrSubstr(&sub,s,pos,i-pos); //sub存放 无需置换的子串\n        StrConcat(&newStr,&newStr,&sub);\n        StrConcat(&newStr,&newStr,v); // 拼接上 置换串\n        pos=i+m;\n    }\n}\nif(StrSubstr(&sub,s,pos,n-pos+1)) StrConcat(s,&newStr,&sub);\nelse StrCopy(s,&newStr);\nreturn; }\n31",
    "2.3 块链存储\n链式存储特点 ：用链表存储串值，易插入和删除\n方法1：链表结点的数据分量长度取1(个字符)\n\n方法1的存储密度为   1/2  \n  \n方法2：链表结点(数据域)大小取n(例如n=4)\n\n\n方法2的存储密度为    9/15 = 3/5\n32",
    "块链类型定义\n#define  CHUNKSIZE 80 //每块大小，由用户定义\ntypedef  struct  Chunk { //首先定义结点类型\n      char  ch[CHUNKSIZE];//每个结点中的数据域\n      struct  Chunk * next ;//每个结点中的指针域\n} Chunk;                                \ntypedef  struct { //定义用链式存储的串类型\n            Chunk  *head;         //头指针\n            Chunk  *tail;            //尾指针\n            int  curLen;              //结点个数\n} LString;\n33",
    "3. 模式匹配 – 暴力算法\n将主串S的第pos个字符和模式串P的第1个字符比较\n若相等，继续逐个比较后续字符\n若不等，则从主串S的(pos+1)字符起，重新与P第1个字符比较\n直到主串S的一个连续子串字符序列与模式串P相等。这时匹配成功，返回S中与P匹配的子序列第一个字符的序号，否则，匹配失败，返回值 0。\n34",
    "暴力求解算法匹配过程示例s=“ababcabcacbab”, t=“abcac”, pos=1\u000bHString的StrIndex(s,t,pos)返回值为6\n35\n第六趟匹配      a b a b c a b c a c b a b\ni=10\na b c a c\ni：主串指针\nj：模式串指针",
    "理想的匹配过程\u000bs=“ababcabcacbab”, t=“abcac”, pos=1\u000bStrIndex(s,t,pos)返回值为6\n36\n第三趟匹配      a b a b c a b c a c b a b\ni=11\n(a) b c a c\ni=7\nj=2\ni=2\nj=0\n每当一趟匹配过程中出现字符比较不等时，不回溯i指针，而是利用已经得到的“部分匹配”的结果将模式串向右滑动尽可能远的距离，然后，继续比较",
    "KMP算法\n由Donald. E. Knuth、James. H. Morris和Vaughan. R. Pratt同时提出来的，故称为KMP算法/1977年\n每当一趟匹配过程中出现字符比较不相等时，不回溯主串指针，而是将模式串向右滑动恰当位置，继续比较\n挖掘了模式串内在的关联信息\n消除了每趟失配后为实施下一趟比较时对主串指针的回退，避免了对已被匹配过的字符的再检查\n提高了模式匹配效率\n令主串的长度是n，模式串的长度是m，则算法的时间复杂度：O(m+n)\n37",
    "在主串的s+j位置和模式串j位置 匹配失败\n这时 ts ts+1 ts+2 … ts+j-1 = p0 p1 … pj-1\n下一趟匹配判断p0 p1 …pj-2 和ts+1 ts+2 … ts+j-1两者是否相等，那么如果p0 p1 … pj-2  p1 p2 …pj-1 ，那么，下一趟必不匹配\n同样地，若p0 p1 …pj-3   p2 p3 …pj-1，则再下一趟也不匹配\n38\nT    t0 t1 … ts-1 ts   ts+1 ts+2 … ts+j-1 ts+j ts+j+1 … tn-1\n                         ‖     ‖        ‖      ‖      ‖       \n P\t               p0  p1   p2    …  pj-1  pj\np0   p1   …  pj-2\np0   p1   …  pj-2",
    "直到对于某一个” k”值，使得：\n                   p0 p1 …pk+1   pj-k-2 pj-k-1 …pj-1  \n\n且                      p0 p1 …pk = pj-k-1 pj-k …pj-1\n\n则\t         p0 p1 …pk = ts+j-k-1 ts+j-k … ts+j-1\n                                          ‖         ‖             ‖\n\t\t\t            pj-k-1   pj-k  …  pj-1\n\n下一趟可以直接用ts+j 与pk+1 与 继续比较\n39\nT    t0 t1 … ts-1 ts   ts+1 ts+2 … ts+j-1 ts+j ts+j+1 … tn-1\n                         ‖     ‖        ‖      ‖      ‖       \n P\t               p0  p1   p2    …  pj-1  pj\n‖\n‖\n‖",
    "模式串P滑动多远？\n40\nS[i-k .. i) = P[j-k ..j)\nx\ny\nz\nP[0.. k)\nP[0.. k)\n主串S\n模式串P\ni\nj\nk\n长：j-k\n位置k：模式串P中j位置前的一个真前缀的位置，该真前缀等于等长的真后缀\n每次模式串P右移的位数与目标串无关，仅依赖于模式串本身和模式串当前指针所在位置\nS[i] ≠P[j] 但 S[i-j  ..  i) = P[0..j)\nP[0..k)= S[i-k..i)\nP[0.. k) = P[j-k  .. j)",
    "引入next数组/next特征向量\nnext[j] = k，表示在模式串P 的P[0,j) 中，自匹配的真前缀和真后缀的(最大)长度为k\n当模式串P中第 j 个字符与主串 S 中相应字符失配时，在下一次匹配中，模式串P应当由next[j]位置的字符与主串中刚失配的字符重新继续进行比较\n41\nS[i-j.. i)\nP(j .. m)\nP(next[j] ..m)\nx\ny\nz\nS(i..n)\nP[0.. j)\nP[0 .. next[j])\n主串S\n模式串P\ni\nj\nk",
    "next数组的定义/给定模式串P\n设模式串P = p0p1… pm-2pm-1\n令SetX={0<k<j | P[0..k) = P[j-k .. j)} \nnext[j] = max (SetX)\n\nT   t0 t1 … ts-1 a  a … a a ti ti+1 … tn-1\nP\t                 a  a … a a pj    \n下一次可能的匹配：\n自匹配子串为a\n             \t                     a a … a a pj    \n自匹配子串为aa\n                                   a a … a a pj\n42\n如果有多个k，应该选最大的k，以免遗漏掉可匹配上的子串",
    "next数组的定义/给定模式串P\n43",
    "StrIndexKMP\nint StrIndexKMP(HString *s, HString *t, int pos) {\nint next[INITSTRLEN]; GetNext(t, next);\nint i,j; \ni=pos-1; j=0; \nwhile(i<s->length && j<t->length)\n    if( j== -1 || s->ch[i] == t->ch[j]) {i++; j++;}\n    else j=next[j];\nif(j>=t->length) \n      return i - t->length+1;\n      //返回s中与t匹配的子序列第一个字符的序号\nelse \n    return 0; //走到主串末尾，匹配失败\n}\n44",
    "45\nKMP算法的匹配实例\n第1趟  主串   a c a b a a b a a b c a c a a b c\n         模式串   a b a a b c a c\n\t                 j=1  next(1) = 0，下次p0\n第2趟 主串 a c a b a a b a a b c a c a a b c\n       模式串    a b a a b c a c\n\t            j=0  next(0)=-1,下次p0, 主串指针加 1 \n第3趟 主串 a c a b a a b a a b c a c a a b c\n      模式串        a b a a b c a c \n                                             j=5  next(5) = 2, 下次p2\n第4趟 主串 a c a b a a b  a a b c a c a a b c\n       模式串               (a b) a a b c a c\n\n若主串长度为n，模式串长度为m，主串与模式串有n个对齐位置，虽然与主串字符比对操作不会后退，但在每个对齐位置有可能比对m次，最坏情况下，比对次数有可能n*m次？",
    "StrIndexKMP\nint StrIndexKMP(HString *s, HString *t, int pos) {\nint next[INITSTRLEN]; GetNext(t, next);\nint i,j; \ni=pos-1; j=0; \nwhile(i<s->length && j<t->length)\n    if(j== -1 || s->ch[i] == t->ch[j]) {i++;j++;}\n    else j=next[j];\nif(j>=t->length) \n      return i -t->length+1;\n      //返回s中与t匹配的子序列第一个字符的序号\nelse return 0; //匹配失败\n}\n46\ni不变j变小，k=2i-j必然增加\ni,j同时加1，k=2i-j必然增加\nWhile循环每迭代一轮，k=2i-j严格递增\n启动时，i=0, j=0，即k=0；\n结束时，i<=n,j>=0,即k<=2n\n主串长度为n\nWhile循环至多执行2n轮\n浅蓝色部分代码的时间复杂度为O(n)",
    "如何求next[j]\n令next[j] = k，表示在模式串P 的P[0,j) 中，自匹配的真前缀和真后缀的最大长度为k，那么，next[j+1]=？分两种情况：\n情况1：当P[j] = P[k]时，next[j+1] = next[j]+1 = k+1\nP[0..j)\nP(j..m)\ny\nP[0..next[j])\ny\nP(next[j]..m)\n模式串P\nj\nj+1\n情况1\nP[0..k)=P[0..next[j])\ny",
    "如何求next[j]\n令next[j] = k\n情况2：当P[j] ≠ P[k]时，next[j+1] 等于 在P[0..next[j])的真前缀与P[0..j+1)中真后缀匹配的最大长度\nnext[j+1]=next[…next[j]…] +1\n48\nP((next[next[j]])..m)\nV\n情况2\nP[0..j)\nP(j..m)\ny\n模式串P\nj\nj+1\nP[0..k)=P[0..next[j])\nU\nP[0..next[j])\nP[0..next[next[j]])\nP[0..next[k])",
    "GetNext\nvoid GetNext (HString *pattern, int next[]){ int j, k;\nj=0; //j: 模式子串的位置\nk= -1; //k: 模式自匹配指针\nnext[0]= -1; \nwhile(j<pattern->length) \n if(k== -1 || pattern->ch[j] == pattern->ch[k]) {\n    j++; k++;\n    next[j]=k;\n }\n else k=next[k]; //失配\n}\n若模式串长度为m，则时间复杂度为O(m)\n49",
    "p3=p0:\nj=4\nk=1\nn4=k\n =1\nk=-1:\nj=2\nk=0\nn2=k =0\nk=-1:\nj=1\nk=0\nn1=k=0\nj=0\nk=-1\nn0=-1\np4=p1:\nj=5\nk=2\nn5=2\np5  p0:\nj=5\nk= n0 =-1\n\np6=p0:\nj=7\nk=0\nn6 =0\np7=p0:\nj=8\nk=1\nn7=1\np3  p1:\nj=3\nk=n1=0\nn3=1\np5  p2:\nj=5\nk=n2 =0\nn5=2\np1  p0 :\nk=n0 =-1\np2=p0:\nj=3\nk=1\nn3=k=1",
    "对next数组的优化：nextval\n51\nS[i-k .. i) = P[j-k ..j)\nx\ny\nz\nP[0.. k)\nP[0.. k)\n主串S\n模式串P\ni\nj\nk\n将主串的S[i]、模式串的P[k]进行匹配。若P[k]=P[j]，那么匹配一定不成功，串还要右滑，滑到next[k]位置。所以，可以直接将j的next值改成 next[k]。\n\n将GetNext中的next[j]=k; 改成：\nIf(pattern->ch[j] == pattern->ch[k]) next[j]=next[k];\nelse next[j]=k;",
    "GetNextVal\nvoid GetNextVal(HString *pattern,int nextval[]){ \nint j,k;  j=0;k= -1; nextval[0]= -1;\nwhile(j<pattern->length) \n if(k== -1 || pattern->ch[j] == pattern->ch[k]){\n    j++;k++;\n    if(pattern->ch[j] == pattern->ch[k]) \t\tnextval[j]=nextval[k];\n    else nextval[j]=k;\n  }\n else k=nextval[k];\n}\n52",
    "53",
    "54\ni2\nY前的模式串中无匹配的真前缀和真后缀即next[6]=0\nY前的模式串中匹配的真前缀和真后缀为ABC，\nnext[7]=3\n主串的信息被记录在模式串中\nMotivation/Solution\n… … ABC123X…\n        ABC123Y\n                      ABC…\n\n\n… … ABCWABCX…\n        ABCWABCY\n                  (ABC)WABCY\n断点续讲",
    "KMP算法-I\n令next[j] = k，表示在模式串P 的P[0,j) 中，自匹配的真前缀和真后缀的最大长度为k\n\n匹配过程：\n当主串的第i个字符 与模式串的第j个的字符失配，那么，(主串的指针不动)主串的第i个字符下一次将与模式串的next[j]个的字符匹配\n在next[j]== -1时，主串后（i++）移指针，模式串重头开始\n55\nPattern： X X  X   X  X  X\n     j:\t     0  1  2   3  4  5\nNext[j]:    -1 0 D1 D2 D3 D4",
    "KMP算法-II\nKMP算法的优点：\n(1) 主串指针不回溯，算法的时间复杂度低，\n(2) 特别适用于模式串与主串之间存在许多部分匹配的情况\n\n\n   A B C D E F … \t\n\n   0 0 0 0\n56\n与暴力算法相比，使用KMP算法会增加额外的时间复杂度",
    "练习\n57\n真前缀和真后缀\nj指针",
    "4. 串操作应用举例\n应用需求：从文件读入书名、书号，建立关键字索引表\n从文件读入书名、书号，从书名中去掉停用词(stop words)，为书名中的关键词建立词表\n对词表中的每个关键字，在索引表中进行查找\n如找到该关键字，则在该项插入书号\n如未找到该关键字，则在索引表上插入此关键字的索引项\n数据结构设计\n词表：线性表，顺序表示，线性表的元素是串\n索引表：线性表，为方便查找，采用顺序存储结构，并保持字典序\n关键字：串，堆分配存储表示，节省空间\n书号：与关键字对应的书号个数不等，线性表，单链表\n58",
    "建立关键字索引表：数据结构\ntypedef struct{\n\tchar *item[];//字符串数组，存放书名中的所有关键字\n\tint last;//词表的长度\n} WordListType;//词表的类型\nWordListType wdlist;//词表\n\n#define MaxKeyNum 2500\ntypedef struct{\n\tHString key; //关键字\n\tLinkedList booknolist; //书号\n} IndexTermType; //索引项\ntypedef struct{\n\tIndexTermType item[MaxKeyNum+1];\n\tint last;\n} IndexListType; //(有序)索引表类型\nIndexListType  idxlist;//索引表\n59\n字典序",
    "串的模式匹配(Pattern Matching)应用\n文本编辑器：编辑和排版\nWord\nOverleaf : Tex，Latex\n正则表达式(Regular Expression)：描述了一种字符串匹配的模式，表达对字符串的一种过滤条件\nA*：A1，A12，Abstract都与它匹配\n正则表达式应用\n利用正则表达式，验证给定一个串：是不是Email地址，是不是身份证号，是不是手机号\n正则表达式拒绝服务攻击\n心电图(ElectroCardioGraph，ECG)检测\n60",
    "61\nAtrial Flutter (AF)\nA noisy ECG piece from a real dataset\nPremature Ventricular Contraction (PVC)",
    "总结\n熟悉串的基本概念\n了解串的存储结构及操作实现\n掌握串的模式匹配(KMP算法)\nKMP算法：\nnext数组和nextval数组的求值\nKMP算法的实现\nKMP算法的匹配过程\nKMP算法的最适用场景\n62",
    "练习\n模式串“aaab”，其next数组值、nextVal数组值分别是什么？\nnext数组：?\nnextVal数组：?\n若主串为“aaaacaaab”，那么完成主串与模式串的匹配，需要几趟匹配？\n63"
  ],
  "Chapter+5-数组与广义表-Part+1": [
    "第五章 数组和广义表\nPart I-数组",
    "目录\n数组的类型定义\n数组的顺序表示和实现\n一维/二维/n维数组(向量/矩阵/n维空间)\n特殊矩阵\n3.1 对称矩阵(的压缩存储(到数组))\n3.2 三对角矩阵(的压缩存储)\n3.3 稀疏矩阵(转置/加法/乘法)\n\n广义表的类型定义\n广义表的表示方法\n广义表的操作实现",
    "1. 数组类型的定义\n数组，作为逻辑结构，是组织数据的一种方式\n数组是相同类型的数据元素的集合\n数组可以看作是数据元素本身还是数据结构的线性结构\n数组元素的下标一般具有固定的下界和上界\n一旦建立数组，数据元素的个数与元素之间的关系就不再发生变动\n\n数组采用顺序存储结构实现\n数组/随机访问=直接访问(vs. 单链表/顺序存取)\n数组是几乎所有程序设计语言都设定为固有(built-in)类型的一种数据类型\n数组，作为存储结构，可以作为其他多种逻辑结构，如线性表、树、图等的顺序存储表示",
    "2. 一维数组\n一维数组的每个元素是一个序对，由下标(index)和值(value)组成，一维数组也被称为向量(Vector)\n不是线性表：数组中可以有没有被赋值的元素\n\n静态数组\n#define maxSize 100\nElemType A[maxSize]; //定义时指定数组大小\n动态数组\nElemType *A;\nA=(ElemType *)malloc(maxSize*sizeof(ElemType));\nif(!A) return ERROR;",
    "一维数组\n基地址",
    "二维数组/矩阵/阵列\n二维数组：数据元素是一维数组的数组\n         typedef T array2[m][n];    //T为元素类型\n         等价于：\n                typedef T array1[n];         //列向量类型\n                typedef array1 array2[m]; //二维数组类型\n二维数组A[m][n] 可看成是由 m 个行向量组成的向量，也可看成是由 n 个列向量组成的向量\n元素在数组的位置：用两个下标(行、列)唯一确定\n\n除了边缘的数组元素，每个数组元素有两个直接前驱(行方向一个、列方向一个)，两个直接后继(行方向一个、列方向一个)\n二维数组不是线性结构，是非线性结构\n6",
    "二维数组\nC语言的实现方式",
    "三维数组",
    "n维数组\n多维数组是一维数组的推广\n多维数组的特点是每一个数据元素受多个线性关系的约束，每一个数据元素可以有多个直接前驱和多个直接后继",
    "n 维数组的映象函数",
    "数组定义\ntypedef struct {\n     ElemType *base;\n     int        dim;\n     int       *bounds;     //数组各维的大小bi\n     int       *constants; //数组映像函数常量基址ci\n} Array;\n\nStatus InitArray (Array *a, int dim, …)；\nStatus DestroyArray (Array *A)；\nStatus Value (Array A, ElemType *e, …)；\nStatus Assign (Array A, ElemType e, ….)；",
    "数组的基本操作\n数组运算通常是随机访问与修改，一般不作插入或删除\n\nInitArray(*A, n, bound1, ..., boundn) //初始化\n操作结果：若维数n和各维长度合法，则构造相应的数组A，并返回OK\nDestroyArray(*A) //销毁\n操作结果：销毁数组A\nValue(A, *e, index1, ..., indexn) //取值函数\n初始条件：A是n维数组，e为元素变量，随后是n个下标值\n操作结果：若各下标不越界，则e赋值为所指定的A的元素值，并返回OK\nAssign(A, e, index1, ..., indexn) //赋值函数\n初始条件：A是n维数组，e为元素变量，随后是n个下标值\n操作结果：若各下标不超界，则e赋值为所指定的A的元素值，并返回OK",
    "数组的基本操作\nStatus Locate(Array A, va_list ap, int *off) { \n       // 若 ap 指示的各下标值合法，则求出该元素在 A 中相对地址 off\n       *off = 0;\n       for ( i=0; i < A.dim; ++i) {\n               ind = va_arg(ap,int) ;\n               if ( ind < 0 || ind >= A.bounds[i] ) return OVERFLOW;\n               *off += A.constants[i] * ind;\n       }\n        return OK;\n}\nStatus Value(Array A, ElemType *e, …) {va_list ap; int off,results;\n         // 若各下标不超界，则 e 赋值为所指定的 A 的元素值，并返回OK\n         va_start(ap, e);\n         if ( ( results = Locate(A, ap, &off) ) <= 0 ) return results;\n         *e = * ( A.base + off );\n         return OK;\n}",
    "数组的基本操作\nStatus Assign(Array A, ElemType e,...) {int result, off; va_list ap;\nva_start(ap, e);\nif ( (result = Locate(A, ap, &off) ) <= 0 )     return ERROR;\n*(A.base + off) = e;\nreturn OK;\n}\n\nint main() {\nArray A; ElemType e;\nInitArray(&A,3,2,3,2);\nAssign(A,30,1,1,1); \nif (Value(A,&e,1,1,1))  printf(\"A(1,1,1):%d\\n\", e);\nreturn 0;\n}",
    "3.特殊矩阵的压缩存储\n特殊矩阵：元素之间存在某种特殊结构关系的矩阵\n值相同的元素或者零元素在矩阵中的分布有一定规律\n对称矩阵\n三对角矩阵\n数值为零的元素数目远远多于非零元素的数目，并且非零元素分布没有规律\n稀疏矩阵\n特殊矩阵的压缩存储\n对可以不存储的元素，如零元素或对称元素，不再存储，以节省存储空间\n操作方便，如：\n能尽可能快地找到与下标值 (i, j) 对应的元素\n能尽可能快地找到同一行或同一列的非零值元",
    "Toeplitz矩阵",
    "车流量估计\n时间约束矩阵T：Toeplitz(0,1,-1)\n空间约束矩阵S\nMining Spatial-temporal Correlation of Sensory Data for Estimating Traffic Volumes on Highways, Mobiquitous 2017, Best paper award runner-up",
    "3.1 对称矩阵(Symmetric Matrix)",
    "行序优先压缩存储下三角矩阵\na00  a10  a11  a20  a21  a22  a30  a31  a32   ……  an-1n-1\n0     1      2      3      4      5      6      7      8              n(n+1)/2-1\nB",
    "3.2 三对角矩阵(Tridiagonal Matrix)\n三对角矩阵\n除主对角线及在主对角线上下最临近的两条对角线上的元素外，所有其它元素均为0\nB  a00  a01  a10  a11  a12  a21  a22  a23   …  an-1n-2  an-1n-1\n0     1      2      3      4      5      6      7      8       9             10\n2个\n2个",
    "三对角矩阵",
    "3.3稀疏矩阵",
    "稀疏矩阵的压缩存储方法",
    "3.3.1 三元组顺序表/有序的双下标法\n#define  MAXSIZE  12500\n typedef struct {\n     int  i, j;            //该非零元的行下标和列下标\n     ElemType  e; // 该非零元的值\n } Triple; // 三元组类型\ntypedef  struct {\n     Triple  data[MAXSIZE + 1]; \n      int      mu, nu, tu; \n     //矩阵的行数、列数和非零元素个数\n} TSMatrix;  // 稀疏矩阵类型\n\n//非零元在表中按行序有序存储\n//便于进行依行顺序处理的矩阵运算",
    "用三元组表表示的稀疏矩阵",
    "三元组表表示的稀疏矩阵及其转置\n原矩阵的三元组表\n转置矩阵的三元组表\n矩阵转置\n矩阵的行列数互换\n将每个矩阵元素的行、列号互换\n按次序排定转置矩阵的元素",
    "稀疏矩阵M转置成T\n按照T中的三元组的次序依次在M中找到相应的三元组进行转置，也就是，按照矩阵M的列序进行转置\n为了找到M中的每一列中所有的非零元素，需要对其三元组表M.data从第一行起整个扫描一遍，由于M.data是以M的行序为主序来存放每个非零元素的，由此得到的恰好是T.data应有的顺序\nM矩阵\nT矩阵",
    "稀疏矩阵转置\nStatus TransposeMatrix(TSMatrix M, TSMatrix *T) {\n//求M矩阵的转置，结果由T返回\nT->mu = M.nu;   T->nu = M.mu; //矩阵的行数、列数互换 \nT->tu = M.tu; //矩阵非零元素\nif (T->tu) {\t\t\t\t\n      q =0;//转置矩阵的元素号\n      for (col = 0; col < M.nu; col++)//一次形成矩阵T的一行\n      \t  for (p = 0; p < M.tu; p++) \t\t\n                 if (M.data[p].j== col) {\t\t\n\t       T->data[q].i = M.data[p].j; T->data[q].j = M.data[p].i;\n                   T->data[q].e = M.data[p].e;\n \t      q++;}\n}\t\nreturn OK;\n}\n设矩阵M有nu列，三元组表总共有 M.tu 项，\nTransposeMatrix的时间复杂度为 O (M.nu*M.tu)\n当M.tu 和 M.mu*M.nu 同数量级时，\nTransposeMatrix的时间复杂度为O(M.mu*M.nu2)\n原矩阵是以行序为先的，保证了扫描时转置矩阵的行序次序\n5.1",
    "对比：一般矩阵的转置算法\nFor(col=1;col<=M.nu;++col)\n\tFor (row=1;row<=M.mu;++row)\n\tT[col][row]=M[row][col]\n其时间复杂度为O(M.mu*M.nu)",
    "稀疏矩阵的快速转置\n预先求得原矩阵M 每一列(即T中每一行)的第一个非零元在T中 的位置，那么，对M转置扫描时，立即确定在转置矩阵 T 三元组表中的位置，并装入它\nM\nT",
    "稀疏矩阵的快速转置\n为了求得原矩阵M 每一列(即T中每一行)的第一个非零元在T中 的位置，建立辅助数组 num和 cpot\nnum[col]：记录矩阵转置前各列(即转置矩阵各行)非零元素个数\ncpot[col]：记录各列非零元素在转置三元组表中开始存放位置\n三元组",
    "for (col=0; col<M.nu; ++col)  num[col] = 0;\nfor (t=0; t<M.tu; ++t)  ++num[M.data[t].j];\ncpot[0] = 0;\nfor (col=1; col<M.nu; ++col)\n\tcpot[col] = cpot[col-1] + num[col-1];\n三元组",
    "稀疏矩阵的快速转置\nStatus FastTransposeSMatrix(TSMatrix M, TSMatrix *T){\n      T->mu = M.nu;  T->nu = M.mu;  T->tu = M.tu;\n      if (T->tu) {\n         for (col=0; col<M.nu; ++col)  num[col] = 0;\n         for (t=0; t<M.tu; ++t)  ++num[M.data[t].j];\n         cpot[0] = 0;\n         for (col=1; col<M.nu; ++col)\n              cpot[col] = cpot[col-1] + num[col-1];\n        for (p=0; p<M.tu; ++p) {\n                      col = M.data[p].j;    q = cpot[col]; //找该元素在T中的位置\n                      T->data[q].i = M.data[p].j; T->data[q].j = M.data[p].i;\n                      T->data[q].e = M.data[p].e;      ++cpot[col];\n        }\n     } // if\n    return OK;\n} // FastTransposeSMatrix\n时间复杂度为O(M.nu+M.tu)\n5.2",
    "稀疏矩阵转置举例\nM矩阵\nT矩阵\np\nq",
    "3.3.2 行逻辑联接的顺序表\n经常需要存取某一行中的非零元\n如果采用三元组顺序表，那么需从头开始进行查找\n行逻辑联接的顺序表：修改前述的稀疏矩阵的结构定义，增加一个数据成员rpos，指示各行第一个非零元素(在data中)的位置\n#define  MAXMN  500  \ntypedef struct {\n        Triple  data[MAXSIZE + 1]; \n         int     rpos[MAXMN + 1]; \n\t   //各行第一个非零元的位置表\n         int     mu, nu, tu; //行数、列数和非零元素个数            \n} RLSMatrix;   // 行逻辑链接顺序表类型\n断点续讲",
    "取值操作：给定一组下标(r, c)，求矩阵中对应元素值\nElemType Value(RLSMatrix M, int r, int c) {\nint p;\n     //给定行和列坐标(r, c)，求取矩阵元素的值\n     p = M.rpos[r]; \n     while (M.data[p].i==r &&M.data[p].j < c) \n              p++;\n      if (M.data[p].i==r && M.data[p].j==c)\n             return M.data[p].e;\n      else return 0;\n} // value",
    "矩阵乘法的经典算法\n以行序访问N\nfor (i=0; i<m; ++i)\n  for (j=0; j<n; ++j) {\n   for (k=0; k<p; ++k) \n   Q[i][k] += M[i][j] * N[j][k];\n   }\n时间复杂度为O(m×n×p)",
    "M=\nN=\nQ=\nM存储在RLSMatrix，各行第一个非零元素在data中的位置分别是：\nM.rpos[]={0,2,4,7}\nN.rpos[]={0,1,3,4,4}\n稀疏矩阵乘法：\n主要对M矩阵的非零元素做处理\n对每一个非零元，找M的列号和N的行号对应的元素相乘\n对Q的元素一行一行的进行处理",
    "40\np\nq\nq\nCtemp[2]：\n记录当前行各元素的累加情况\n根据N.rpos[]\n根据M.rpos[]",
    "稀疏矩阵相乘\nStatus MultSMatrix(RLSMatrix M, RLSMatrix N, RLSMatrix *Q) {\n      if (M.nu != N.mu) return ERROR;\n      Q->mu = M.mu; Q->nu = N.nu; Q->tu = 0; \n      if (M.tu*N.tu != 0) {   // Q是非零矩阵\n         for (arow=0; arow<M.mu; ++arow) { \n             // 处理M的每一行\n          } // for a row\n       } // if    \n       return OK;\n} // MultSMatrix\n5.3",
    "稀疏矩阵相乘：处理M的每一行\nfor(i=0;i<N.nu; i++) ctemp[i]=0;                // 当前行各元素累加器清零\nQ->rpos[arow] = Q->tu;      \nfor (p=M.rpos[arow]; p<s;++p) {\n        //对M矩阵当前行中每一个非零元\n        brow=M.data[p].j;          \n       for (q=N.rpos[brow];  q< t;  ++q) { \n                ccol = N.data[q].j;    // 乘积元素在Q中列号\n                ctemp[ccol] += M.data[p].e * N.data[q].e;\n        } // for q, 计算Q中第arow行的积并存入ctemp[]\n} // 求得Q中第crow( =arow)行的非零元\nfor (ccol=0; ccol<Q->nu; ++ccol) //将ctemp[]中非零元素压缩存储到Qdata\n    if (ctemp[ccol]) {\n        if (Q.tu > MAXSIZE) return ERROR;\n        Q->data[Q->tu].i = arow;         \tQ->data[Q->tu].j = ccol;\n        Q->data[Q->tu].e = ctemp[ccol];       Q->tu++;\n  } // if\nif (arow < M.mu-1)\n         s=M.rpos[arow+1];\n else s=M.tu+1;\nif (brow < N.mu) \n     t = N.rpos[brow+1];\nelse  t = N.tu+1;",
    "算法的时间复杂度",
    "3.3.3 十字链表(Orthogonal linked list)\n当矩阵的非零元个数和位置在操作中变化较大时，就不宜采用顺序存储结构来表示三元组的线性表，而是采用链式存储结构表示三元组的线性表\n每个非零元由一个含5个域的结点表示(i, j, e, right, down)\n\ntypedef struct OLNode{\n\tint                         i, j;\n\tElemType         e;\n      \tstruct OLNode  *right, *down;\n} OLNode, *Olink;\n\ntypedef struct{\n\t//行和列链表 头指针向量的基址\n\tOlink   *rhead, *chead;\n\tint mu, nu, tu;\n} CrossList;",
    "十字链表举例\n2\n3\n5\n-1\n0\n0\n0\n3\n^\n^\n1\n1\n^\n^\n^\n^\n2\n0",
    "基于十字链表创建矩阵\nStatus CreatSMatrix_OL(CrossList *M) {\n   scanf(\"%d %d %d\\n\", &m, &n, &t);    M->mu =m;      M->nu=n;      M->tu=t;\n   if (!(M->rhead=(Olink *)malloc((m+1)*sizeof(Olink))))   return OVERFLOW;\n   if (!(M->chead=(Olink *)malloc((n+1)*sizeof(Olink))))   return OVERFLOW;\n   for(i=0;i<m;i++) M->rhead[i] =NULL;\n   for(i=0;i<n;i++) M->chead[i] = NULL;\n   while(t>0) {\n          scanf(\"%d %d %d\\n“, &i, &j, &e);\n          if (!(p=(OLNode *)malloc(sizeof(OLNode))))   return OVERFLOW;\n          p->i=i; p->j=j; p->e=e; //生成OLNode结点\n          if (M->rhead[i] == NULL || M->rhead[i]->j > j){ //成为行的第一个非零元素\n                       p->right = M->rhead[i]; M->rhead[i] = p;}\n           else{   \n\t    for (q= M->rhead[i]; (q->right) && q->right->j < j; q=q->right) ; //找到插入点\n                      p->right = q->right;   q->right = p; //插到q后\n           }\n           if (M->chead[j]==NULL || M->chead[j]->i>i){//成为列的第一个非零元素\n                       p->down = M->chead[j]; M->chead[j]=p;}\n           else{    for (q=M->chead[j]; (q->down) && q->down->i < i; q=q->down) ;\n                       p->down = q->down; q->down = p;\n           }  \n       t--; } }\n5.4"
  ],
  "Chapter+5-数组与广义表-Part+2": [
    "第五章 数组和广义表\nPart II-广义表",
    "目录\n数组的类型定义\n数组的顺序表示和实现\n一维/二维/n维数组\n特殊矩阵的压缩存储(到数组)\n对称矩阵/三对角矩阵/稀疏矩阵\n\n广义表的类型定义\n广义表的表示方法\n广义表的操作实现",
    "4. 广义表(Generalized List)",
    "广义表中的数据元素有相对次序，这个顺序不能交换\n广义表是递归定义的线性结构\n广义表是一个多层次的线性结构\n广义表可以是一个递归的表\n广义表可以共享\n\nD=(E, F)\nE=(a, (b, c))\nF=(d, (e))\n——有向图\n——类似线性结构\n——层次结构\nF(4, F)\n广义表：非线性结构",
    "广义表举例：表头/表尾",
    "广义表的表头和表尾\n任何一个非空广义表LS = ( 1, 2, …, n)均可分解为：\n表头  Head(LS) = 1\n表尾  Tail(LS) = (2, …, n) \n任何一个非空的广义表的表尾必定是一个广义表\n\nD = ( E, F ) = (E(a, (b, c))，F ) = ((a, (b, c))，F ) \nHead( D ) = E        Tail( D ) = ( F )\nHead( E ) = a         Tail( E ) = ( ( b, c) )\n\nHead( (( b, c)) ) = (b, c)   Tail( ((b, c)) ) = ( )\nHead( (b, c) ) = b    Tail( (b, c) ) = ( c )\nHead( ( c ) ) = c        Tail( ( c ) ) = ( )",
    "广义表举例\n空表",
    "5. 广义表的链式表示(存储结构)\n广义表的数据元素具有不同的结构，且是一个带深度的层次结构\n难以用顺序存储结构来存放，而是采用链式存储结构\n广义表中元素可以是原子或者广义表\n用Union类型表示：表结点，原子结点\n\n构造存储结构的两种分析方法\n表头表尾分析法：广义表 = 表头 + 表尾 \n子表分析法：广义表 = 子表1 + 子表2 +  ··· + 子表n",
    "5.1 表头表尾分析法/头尾链表存储结构\n若广义表不空，则可分解为表头和表尾；反之，一对确定的表头和表尾可唯一确定广义表\ntypedef enum {ATOM, LIST} ElemTag;\ntypedef struct GLNode {\t\n     ElemTag tag; // ATOM or LIST\n     union { //原子结点和表结点的联合部分\n          AtomType atom;\t          \n          struct {struct GLNode *hp, *tp;} ptr;\n\t//ptr.hp, ptr.tp指向表结点的表头、表尾\n          }\n} Glist;",
    "例子\nA( )\nB( e ) \nC(a, (b, c, d))\nD(A, B, C)\nE(a, E )\nA=NIL\ntypedef struct GLNode {\t\n     ElemTag tag; // ATOM or LIST\n     union { //原子结点和表结点的联合部分\n          AtomType atom;\t          \n          struct {struct GLNode *hp, *tp;} ptr;\n          }\n} Glist;",
    "5.2 子表分析法\ntypedef enum {ATOM, LIST} ElemTag;\ntypedef struct GLNode {\t\n     ElemTag tag; // ATOM or LIST\n     union { //原子结点和表结点的联合部分\n          AtomType atom;\t          \n\tstruct GLNode *hp;//指向子表的指针\n     };\n     struct GLNode *tp;\n    //指向同一层下一个表元素结点的指针\n} Glist;",
    "例子\nA( )\nB( e ) \nC(a, (b, c, d))\nD( A, B, C)\nE( a, E )",
    "广义表的应用：m元多项式的表示",
    "m元多项式的表示\ntypedef struct MPNode {\t\n     ElemTag  tag; \n     int            exp; //指数域\n     union {\t//原子结点和表结点的联合部分\n          float   coef;   //系数域\t          \n\tstruct MPNode *hp;\n     };\n     struct MPNode *tp;//相当于线性链表的next\n} Mplist;      //m元多项式广义表类型定义\nTag=1  exp   hp   tp",
    "P\n1   2\nm元多项式举例",
    "5. 广义表的基本操作\n//创建和销毁\nInitGList(*L); //创建空的广义表\nCreateGList(*L, S); //由字符串创建广义表\nDestroyGList(*L);\n//插入、删除、拷贝\nInsertFirst_GL(*L, e); //插入e成L的第一个元素\nDeleteFirst_GL(*L, *e);\nCopyGList(*T, *L);//将广义表L复制到T\n//状态函数\nGListLength(L);   GListDepth(L);\nGListEmpty(L);   GetHead(L);    GetTail(L);\n//遍历\nTraverse_GL(L, Visit());",
    "广义表操作的实现\n创建广义表\n求广义表的深度\n复制广义表\n删除广义表的元素\n\n广义表的特点\n广义表 = 表头 + 表尾 \n广义表 = 子表1 + 子表2 +  ··· + 子表n\n\n递归(分而治之)\n递归算法设计中的关键问题是如何将一个子问题的解组合成原问题的解",
    "创建广义表",
    "创建广义表",
    "创建广义表\nvoid CreateGList(Glist *L, SString S) {\nif  (!strComp(S,”()”))  L = NULL;  // 创建空表\nelse {\n   // 生成表结点\n   if(!(L=(Glist*)malloc(sizeof(GLNode)) )) return OVERFLOW; \n   if (StrLen(S)==1) { //建立单原子广义表\n       L->tag=ATOM, L->atom = S; }\n   else {\n       L->tag=LIST;   p=L；\n       //设sub为 脱去串 S 最外层括弧的子串\n      StrSubStr(sub, S,2,StrLen(S)-1);  \n      … … //为sub中所含n个子串建立n个子表\n    } // else\n  }//else\nreturn OK;\n}",
    "do { //重复建n个子表\n //分离出子表串hsub=I\n Sever(sub, hsub); \n //创建由串hsub定义的广义表pptr.hp\n CreateGList(p->ptr.hp, hsub); \n q=p; \n if (!IsStrEmpty(sub) { \n   //余下的表不为空\n   if(!(p=(GLNode*)malloc(sizeof(GLNode)) )) return OVERFLOW;\n   //建下一个子表的表结点*(p->ptr.tp) \n   p->tag = LIST;    q->ptr.tp=p;\n   }\n} while (!IsStrEmpty(sub));\nq->ptr.tp = NULL;    // 表尾为空表",
    "Status  Sever(SString str, SString hstr) {\n//将非空串str分割为两部分：hstr为第一个逗号之前的子串，str为之后的子串\n   n = StrLength(str);   \n   i=0;   k=0; //k:尚未配对的左括号个数\n   do{\n         ++i;\n         StrSubStr(ch, str, i, 1); //取一个字符\n         if ( ch==‘(’ )  ++k;\n         else ( ch==‘)’ )   --k;\n   }while ( i<n && (ch!=‘,’ || k!=0) );\n   if (i<n){ //遇到逗号或括号\n \tStrSubStr(hstr, str, 1, i-1); \n \tStrSubStr(str, str, i+1, n-i);\n   }\n   else {  StrCopy(hstr, str);   StrClear(str); }\n} //sever",
    "求广义表的深度\nint GlistDepth(Glist *L) { //返回指针L所指的广义表的深度\nif (!L) return 1; \nif (L->tag == ATOM) return 0; \nfor (max=0, pp=L; pp; \n      pp=pp->ptr.tp) { //求以pp    \n  //ptr.hp为头指针的子表深度\n dep = GlistDepth(pp->ptr.hp);\n  if (dep > max) max = dep;\n}\n//非空表的深度是各元素深度的最大值加1\nreturn max + 1;\n} // GlistDepth",
    "复制广义表\n将广义表L分解成表头和表尾两部分，分别(递归)复制求得新的表头和表尾\n新的广义表T由新的表头和表尾构成\n基本项:\nInitGList(T)  当L为空表\n递归项：\nCOPY(表头）{复制表头}\nCOPY(表尾)   {复制表尾}\nStatus CopyGList(Glist *T, Glist *L) {\nif (!L) T = NULL;  // 复制空表\nelse {\n  //建立表结点\n  if ( !(T =(GList*)malloc(sizeof(GLNode))))\n         return OVERFLOW; \n  T->tag = L->tag;\n  if (L->tag == ATOM) \n        T->atom = L->atom; //复制单原子\n else {\n    CopyGList (T->ptr.hp, L->ptr.hp);\n    //复制L->ptr.hp到T->ptr.hp\n    CopyGList (T->ptr.tp, L->ptr.tp);\n   //复制L->ptr.tp到T->ptr.tp\n   }\n} // else\nreturn OK;\n} // CopyGList\n语句 CopyGList(T->ptr.hp, L->ptr.hp);\n等价于\n    CopyGList(newhp, L->ptr.tp);\n     T->ptr.hp = newhp;",
    "a1\na2\na3\nan\n…\n\nL\na1\na2\na3\nan\n\nL\na1\na2\na3\nan\n\nL\n若“a1=x”, 则 L 仍为删除 x 后的链表头指针\n若“a1≠x”, 则余下问题是考虑以 L->next 为头指针的链表\n…\n…\nL->next\nL->next=p->next\np=L->next\n删除广义表中所有元素为x的原子结点\n删除单链表中所有值为x 的数据元素",
    "删除广义表中所有元素为x的原子结点\n删除单链表中所有值为x 的数据元素\nvoid delete(LinkedList *L, ElemType x) {\n // 删除以L为头指针的带头结点的单链表中\n // 所有值为x的数据元素\n  if (L->next) {\n     if (L->next->data==x) {\n        p=L->next;  L->next=p->next;\n        free(p);  delete(L, x);\n        }\n     else  delete(L->next, x);\n  }\n} // delete",
    "删除广义表中所有元素为x的原子结点\n广义表的数据元素可能还是个广义表；删除时，不仅要删除原子结点，还需要删除相应的表结点\nvoid Delete_GL(Glist *L, AtomType x) {\n  //删除广义表L中所有值为x的原子结点\n  if (L) {\n     head = L->ptr.hp;  // 考察第一个子表\n     if ((head->tag == Atom) && (head->atom == x)) \n       {  …………….  } // 删除原子项 x的情况\n     else \n       {……………. }// 第一项没有被删除的情况 \n  }\n} // Delete_GL",
    "p=L;    L = L->ptr.tp; //修改指针\nfree(head);               //释放原子结点\nfree(p);                      //释放表结点\nDelete_GL(L, x);  //递归处理剩余表项\n1\nL\n0   x\n1\np\nL\nhead\n1\nL\n1\n1\nhead\nL->ptr.tp\nif (head->tag == LIST) //该项为广义表\n   Delete_GL(head, x);\n   Delete_GL(L->ptr.tp, x);",
    "总结\n了解数组的两种存储表示方法，并掌握数组在以低下标为主序的存储结构中的地址计算方法\n掌握对特殊矩阵进行压缩存储时的下标变换公式\n了解稀疏矩阵的不同压缩存储方法的特点和适用范围，领会以三元组表示稀疏矩阵时进行矩阵运算采用的处理方法\n掌握广义表的结构特点及其存储表示方法(头尾链表存储法)\n掌握(采用递归算法实现)对广义表的基本操作",
    "学完了《数据结构》中的线性结构…\n数据结构的多样性\n(Chapter5)广义表的两种存储方式\n根据应用需求，选定数据结构\n(Chapter2) 现有应用，其主要的操作是 找表头结点、找表尾结点和找P结点的前驱结点，试问，用哪个数据结构比较好？\n带头结点的单链表L\n带头结点的循环单链表(头指针)L\n带尾指针R的循环单链表\n带头结点的双向循环链表L \n数据结构选择的权衡考虑：性能、方便性和可维护性(维护代价的高低)\n(Chapter5)稀疏矩阵：行逻辑联接的顺序表加了rpos数组；矩阵快速转置中用到的辅助数组 num和 cpot\n数据结构的语义通过操作来体现\n(Chapter2)单链表的头结点\n用画图来帮助思考"
  ],
  "Chapter+6-树与二叉树-Part+1": [
    "第六章 树和二叉树\nPart-I",
    "目录\n基本概念\n二叉树及其存储表示\nSqBiTree, \nBiTree, TriTree, BPTree\n二叉树的遍历\n先序、中序、后序\n层次序\n\n(二叉树变体) Huffman树(严格二叉树)\n(二叉树变体)线索二叉树\n树\n森林",
    "1. 树相关的术语\n递归定义",
    "树的逻辑表示方法\n树形表示法：用一个圆圈表示一个结点，圆圈内的符号代表该结点的数据信息，结点之间的关系通过连线表示\n\n\n\n\n圆括号表示法，也称为广义表表示法，它是使用括号将集合层次与包含层次关系显示出来\n例如：A( B(E,F(K,L)), C(G), D(H,I,J(M)) )",
    "树的逻辑表示方法\n文氏图(Venn diagram)表示法/嵌套集合表示法：每棵树对应一个圆圈，圆圈内包含结点和子树的圆圈，同一个根结点下的各子树对应的圆圈是不能相交的\n目录结构表示法",
    "树相关的术语-I\n结点：包含数据元素及若干指向其子树的分支(指针)\n结点的孩子(child)：若结点的子树非空，结点子树的根即为该结点的孩子\n双亲(parent)：若结点有孩子，那么该结点就是孩子结点的双亲\n兄弟(sibling)：同一双亲结点的孩子互称为兄弟\n堂兄弟：双亲在同一层的结点",
    "树相关的术语-II\n结点的祖先(ancestor)：从根结点到该结点所经分支上的所有结点\n结点的子孙(descendant)：某一结点的孩子以及这些孩子的孩子都是该结点的子孙\n以某结点为根的子树中任一结点都是该结点的子孙\nFor two nodes in a tree, X and Y\nX is an ancestor of Y if \nX is the parent of Y or\nX is the ancestor of the parent of Y\nY is a descendant of X if \nY is a child of X or\nY is the descendant of a child of X",
    "树相关的术语-III\n结点的度(degree)：结点所拥有的子树的数量\n叶子结点(leaf)：度为零的结点，终端结点\n分支结点：度大于零的结点，非终端结点\n结点之间的路径：由从一个结点到另一个结点的所径分支和结点组成\n从根到结点的路径：由从根到该结点所经分支和结点构成\n\n树的度：树中各个结点的度的最大值，通常将度为m的树称为m叉树/m次树\n树的宽度：统计树中每一层的结点数量，取最大的数量作为树的宽度",
    "树相关的术语-IV\n结点的层次/深度：规定根结点为第一层，其孩子结点的层次等于它的层次加一，若某结点在i层，则其子树的根就在第i+1层\n结点的高度：叶结点的高度为1，非叶结点的高度等于它的孩子结点高度中的最大值加1\n树的深度：树中(叶子)结点的最大层次\n树的高度：根结点的高度\n树的高度=树的深度",
    "树相关的术语-V\n有序树：树中结点的各棵子树 T0, T1, …是有次序的(不能互换)\n无序树\n\n满m叉树/满m次树：除根结点和叶子结点外，其余结点度数均为m\n完全m叉树/完全m次树：按照满m次树的层序编号后，最高层连续缺少编号最大的若干个结点，但至少有一个结点 \n森林：森林是m棵树的集合(m≥0)",
    "线性结构 vs. 树型结构\n第一个数据元素\n无前驱\n最后一个数据元素\n无后继\n其它数据元素\n一个前驱、一个后继\n根结点\n无前驱\n多个叶子结点\n 无后继\n其它数据元素\n一个前驱、一到多个后继\n以分支关系定义的层次结构\n分支关系：祖先-后代，一般-特殊，整体-部分等",
    "树的基本操作-I\n插入类\nInitTree(*T)  // 初始化置空树  \nCreateTree(*T, definition)   // 按定义构造树\nAssign(T, cur_e, value)   // 给当前结点赋值\nInsertChild(*T, &p, i, c)  \n// 将以c为根的树插入为结点p的第i棵子树\n删除类\nClearTree(*T) // 将树清空\nDestroyTree(*T)  // 销毁树的结构\nDeleteChild(*T, *p, i)  // 删除结点p的第i棵子树",
    "树的基本操作-II\n查找类\nRoot(T) // 求树的根结点\nValue(T, cur_e) // 求当前结点的元素值 \nParent(T, cur_e) // 求当前结点的双亲结点\nLeftChild(T, cur_e) // 求当前结点的最左孩子 \nRightSibling(T, cur_e)  // 求当前结点的右兄弟\nTreeEmpty(T)  // 判定树是否为空树 \nTreeDepth(T)  // 求树的深度\nTraverseTree(T, Visit() )  // 遍历",
    "2. 二叉树 (Binary tree)\nA binary tree is either empty or it contains a root node and left- and right-subtrees that are also binary trees\n定义：一种树型结构，它的特点是每个结点至多只有两棵子树，并且，二叉树的子树有左右之分，其次序不能任意颠倒\nL\nL\nR\nR\n二叉树的五种不同形态",
    "二叉树的性质-I",
    "二叉树的性质-II",
    "满二叉树 (Full binary tree)",
    "完全二叉树 (Complete binary tree)",
    "完全二叉树",
    "完全二叉树",
    "二叉树的存储结构\n二叉树的顺序存储结构\n#define  MAX_TREE_SIZE  100      \n// 二叉树的最大结点数\ntypedef TElemType SqBiTree[MAX_TREE_SIZE];   \n\nSqBiTree  bt;\n二叉树的链式存储结构\n二叉链表BiTree\n三叉链表TriTree\n双亲链表BPTree",
    "二叉树的顺序存储结构\n#define  MAX_TREE_SIZE  100      \n// 二叉树的最大结点数\ntypedef TElemType SqBiTree[MAX_TREE_SIZE];   \nSqBiTree  bt;\n\n\n\n\n\n\n\n\n完全二叉树的顺序表示    一般二叉树的顺序表示",
    "二叉树的顺序存储结构\n极端情形：只有右单支的二叉树",
    "二叉树的链式存储表示：二叉链表\n结点结构\nroot\ntypedef struct BiTNode { \n    // 结点结构\n    TElemType      data;\n    struct BiTNode  *lchild, *rchild;\n    // 左右孩子指针\n} BiTree;",
    "二叉树的链式存储表示：三叉链表\nroot\n结点结构:\ntypedef struct TriTNode { \n      // 结点结构\n      TElemType       data;\n      struct TriTNode  *lchild, *rchild; \n      //左右孩子指针\n      struct TriTNode  *parent;  \n      //双亲指针 \n   } TriTree;",
    "二叉树的链式存储表示：双亲链表\nTypedef struct BPTNode{\n\tTElemType data;\n\tint parent;\n\tChar LRTag;\n}BPTNode;\n\nTypedef struct BPTTree{\nBPTNode    \n      nodes[MAX_TREE_SIZE];\nint num_node;\nint root;\n}BPTree;",
    "3. 二叉树的遍历\n二叉树的遍历：顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次\n访问：输出结点信息，结点赋值等等\n先左后右的遍历\n设访问根结点记作 D，遍历根的左子树记作 L，遍历根的右子树记作 R，则按照访问根结点的先后，可能的遍历次序有 先序 (DLR)、中序(LDR)、后序(LRD)\n先右后左的遍历\n先上后下的按层次遍历",
    "二叉树的遍历\n先序遍历\nA B D E C F G\n中序遍历\nD B E A F C G\n后序遍历\nD E B F G C A",
    "二叉树的遍历\n先序序列：\n中序序列：\n后序序列：\nA B C D E F G H K\nB D C A E H G K F\nD C B H K G F E A\n叶子结点：D、H、K\n树的深度：5",
    "先序遍历 (Preorder Traversal)\nStatus PreorderTraverse (BiTree *T,  Status(*Visit)(TElemType e)) {\nif (T) {\n      if (Visit(T->data))            // 访问结点\n         if (PreorderTraverse (T->lchild, Visit)) //遍历左子树\n             if (PreorderTraverse (T->rchild, Visit)) //遍历右子树\n             return OK;\n         return ERROR;\n}\n else  return OK;\n}\n若二叉树为空，则空操作\n否则\n访问根结点 (D)\n先序遍历左子树 (L)\n先序遍历右子树 (R)\n基本操作是 Visit(访问结点)\n对n个结点的二叉树，遍历操作的时间复杂度为O(n)",
    "关于递归程序时间复杂度的Master定理",
    "树的遍历\n中序遍历 (Inorder Traversal)\n若二叉树为空，则空操作\n否则，\n中序遍历左子树 (L)\n访问根结点 (D)\n中序遍历右子树 (R)\n后序遍历 (Postorder Traversal)\n若二叉树为空，则空操作\n否则，\n后序遍历左子树 (L)\n后序遍历右子树 (R)\n访问根结点 (D)",
    "二叉树的创建\nBiTree *CreateBiTree() {\n  //按先序输入二叉树中结点的值即字符，空格或Z\n  //表示空树，构造二叉链表表示的二叉树\n  scanf(\"%c\",&x);\n  if (x==‘Z’) bt = NULL;\n  else {\n\t bt=(BiTree *)malloc(sizeof(BiTree));\n\t if(!bt) return NULL;\n\t    bt->data=x; //生成根结点\n\t    bt->lchild =CreateBiTree(); //构造左子树\n\t    bt->rchild =CreateBiTree(); //构造右子树\nreturn bt;\n}// CreateBiTree",
    "例子\n先序次序输入\nABZCDZZZEZFGHZZKZZZ \n\n先序输出：\nABCDEFGHK\n中序输出：\nBDCAEHGKF\n后序输出：\nDCBHKGFEA",
    "例子：统计叶子结点的个数\n叶子结点：左右子树都为空\n\nint CountLeaf(BiTree *T);  //在头文件中的定义\n\nint CountLeaf(BiTree *T) { //实现\nint countNum=0;\nif (T) {\n\tcountNum=CountLeaf (T->lchild);\n\tif(!T->lchild && !T->rchild) countNum++;\n\tcountNum += CountLeaf (T->rchild);\n\t}\nreturn countNum;\n}\n\nNum=CountLeaf(t); \t //调用",
    "例子：求树的深度",
    "遍历算法的非递归描述\n利用栈(存放走过但未访问的结点)实现树的中序遍历\na\nc\nd\ne\nb\na\na\nd\na\na\nb左空\n退栈\n访问b\nd左空\n退栈\n访问d\n退栈\n访问a\ne左空\ne\nc\n退栈访问e\nc\nc\n右空\n退栈访问c 栈空结束\n1\n2\n3\n4\n1\n2\n4\n3\n5\n5\n6\n6\n6\n7\n7\n8\n8\n8\n9",
    "利用栈实现中序遍历的非递归算法1\nvoid Inorder_iter2( BiTree *T, Status(*Visit)(TElemType e) ){ \nSqStack S; InitStack(&S); \nBiTNode *p; p = T; Push(&S,p);\nwhile (!IsStackEmpty(&S)){\n    while(GetTop(&S,&p) && p) \n\tPush(&S,p->lchild); //左子树入栈\n    Pop(&S,&p); //空指针退栈\n    if(!IsStackEmpty(&S)){\n        Pop(&S,&p); //退栈\n        if(!Visit(p->data)) return ERROR;//访问\n        Push(&S,p->rchild); //遍历右子树\n    } //if\n}//while\nreturn OK;\n}",
    "利用栈实现中序遍历的非递归算法2\nvoid Inorder_iter1(BiTree *T, Status (*Visit)(TElemType e)) {\nSqStack S; InitStack(&S);\nBiTree *p; p = T;\nwhile (p || ! StackEmpty(&S)){\n       if (p) {Push(&S, p);  p= p->lchild;} \n\t\t//该子树沿途结点进栈\n       else { Pop(&S, &p); //退栈\n                if (!Visit (p->data)) return ERROR; //访问\n                p = p->rchild; //遍历指针进到右孩子\n               }\n} //while\nreturn OK;\n}",
    "层次序遍历二叉树\n从根结点开始，按层次逐层遍历\n\n\n\n\n\n\n层次遍历需要采用队列\np=树的根，当p不空时：入队列；否则返回\n当队列不空时：取队头并访问，并将其非空左右孩子入队列\n遍历顺序",
    "例子：表达式树(Expression tree)\n用二叉树存储表达式\n若exp=opnd1 optr opnd2，则optr放根结点，opnd1,2放左右子树\n例：a+b*(c-d)-e/f\n\n\n\n\n\n\n\n\n\n利用二叉树，可以在三种表达式之间转换\n先序遍历：前缀表达式\n-+a*b-cd/ef\n表达式的前缀表示/波兰式表达 (prefix/Polish notation)\n中序遍历：中缀表达式\na+b*c-d-e/f\n表达式的中缀表示(infix notation)\n后序遍历：后缀表达式\nabcd-*+ef/-\n表达式的后缀表示/逆波兰表示(postfix notation, RPN(Reverse Polish Notation))\n利用后缀表达式求表达式的值"
  ],
  "Chapter+6-树与二叉树-Part+2": [
    "第六章 树和二叉树\nPart-II\n1",
    "目录\n基本概念\n二叉树及其存储表示\n二叉树的遍历：先序、中序、后序、层次序\n\n\n(二叉树变体) Huffman树\n最优判定树\nHuffman编码\n(二叉树变体)线索二叉树\n\n树\n森林\n2",
    "练习\n给定完全二叉树的中序遍历序列是否可以唯一确定一颗完全二叉树？\n能，给定了完全二叉树的结点，\n其树的形态已完全决定\n若完全二叉树的中序遍历序列\n为8492X51367，则这棵树是：\n\n若二叉树的先序序列 为ABCDEFG，中序序列为 CBEDAFG，请画出该二叉树\n3",
    "练习\n利用二叉树的先序序列和中序序列可以唯一确定一颗二叉树；\n利用二叉树的后序序列和中序序列可以唯一确定一颗二叉树；\n利用二叉树的先序序列和后序序列不能唯一确定一颗二叉树；\n\n设一颗二叉树的先序序列为abdecf，后序序列为debfca，则该二叉树的中序遍历为：\n adbecf? dfecab? adbdef? dbeacf?\ndbeacf\n若二叉树的层次序序列为{abcdef}，中序序列为{dbaecf}，请画出该二叉树\n4",
    "4. Huffman树\n5",
    "基本概念\n带权路径长度达到最小\nHuffman树\n6",
    "构造Huffman树\nF：二叉树的集合，用二叉树的树根表示二叉树\n7\n每次挑出最小的两个值",
    "构造Huffman树 (贪心算法)\n8",
    "Huffman树的应用：最优判定树\n根据考试成绩给出分类统计结果\n考试成绩分布表\n不及格\n及格\n中\n良\n优\n<60?\n<70?\n<80?\n<90?\n0.10\n0.15\n0.25\n0.35\n0.15\n≥\n≥\n≥\n≥\n<\n<\n<\n<\n数据分布概率\nWPL = 0.10*1 + 0.15*2 + 0.25*3+ 0.35*4 + 0.15*4  \n= 3.15\n9",
    "Huffman树的应用：最优判定树\n判定树是一棵二叉树，叶子结点是比较结果，内结点是比较过程，叶子结点所带权值是概率\n最优判定树(Optimal decision tree)：利用Huffman树，可以在构造判定树(决策树)时让平均判定(比较)次数达到最小\n10",
    "最优判定树：按Huffman算法构造判定树\nWPL = 0.10*3+0.15*3+0.25*2+0.35*2+0.15*2\n         = 0.3+0.45+0.5+0.7+0.3 = 2.25\n11",
    "Huffman树的应用：Huffman编码\n编码问题\n给定一段报文，给出每个字符的编码\n例如：给定 CAST CAST SAT AT ATASA\n字符集合是 {C, A, S, T}，各个字符出现的频度(次数) 分别是{2, 7, 4, 5} =W\n能否减少总编码长度，使得发出同样报文，可以用最少的二进制代码？\n等长编码方案\n给每个字符以等长编码\n用2位二进制数，A : 00   T : 10    C : 01    S : 11\n总编码长度为 (2+7+4+5) * 2 = 36\n12",
    "Huffman编码\n不等长编码方案\n按各个字符出现的概率不同而给予不等长编码，可以减少总编码长度\n例如： 字符出现频率分别是C：2次，A：7次，S：4次， T：5次，则可编码成：\n\t\tA : 0    T : 10     S : 111   C : 110 \n它的总编码长度：7*1+5*2+( 2+4 )*3 = 35，比等长编码的情形要短\n但是有时这样的电文会产生歧义\n例如：A : 0   T : 00  C : 1    S : 01，那么0000代表什么？\n前缀编码：任何一个字符的编码都不是同一字符集中另一个字符的编码的前缀\n编码的前缀性质可以使译码方法非常简单\n13",
    "Huffman编码\n利用二叉树可以构造一种不等长的二进制编码，而且得到的必为二进制前缀编码\n构造以出现频率为权值的Huffman树，就能得到相应的Huffman编码，这是一种最优前缀编码，即使所传电文的总长度最短\n编码树\n字符及出现频率：\nC：2次，A：7次，S：4次，T：5次\n字符及编码：\nA (0)，T (10 )，C (110)，S (111)\n编码110011110 可以唯一的分解为\n110，0，111，10，因而其译码为CAST\n14",
    "Huffman编码\n对一组字符集进行Huffman编码，\n可以得出多种编码方案，且这些编码都是最优二进制编码\n15",
    "Huffman树\n性质\nHuffman树中没有度为1的结点，树中任意非叶子结点都有2个孩子，这类树又称为正则或严格二叉树(regular/strict binary tree)\n一棵有n个叶子结点的Huffman树共有2n-1个结点 \n总结点数=度0的结点数\n+ 度1的结点数\n+ 度2的结点数\n= n + 0 +  n-1 = 2n-1\n用三叉静态链表表示Huffman树\ntypedef struct{\n    char data;\n    int weight;\n    int parent, lchild, rchild;\n} HTNode;\ntypedef struct{\n    HTNode elem[MAXNum];\n    int num, root;\n    //num:叶结点数，root:根\n}\n16",
    "Huffman编码算法\ntypedef struct {\n       unsigned int  weight;\n       unsigned int parent, \n                       lchild, rchild;\n} HTNode, *HuffmanTree;\n\ntypedef char **HuffmanCode;\n17",
    "Huffman编码算法：返回字符的编码\nHuffmanCode HuffmanCoding (int *w, int n) {//w存放n个字符的权值\nHuffmanCode HC; HuffmanTree HT, p;\nchar *cd;\nint i,m,s1,s2,start,c,f;\n    m = 2*n-1; \n    HT = (HuffmanTree)malloc((m+1)*sizeof(HTNode));\n    for (p=HT+1, i=1; i<=n; ++i,++p,++w) {  p->weight = *w;\n        \tp->lchild = p->rchild = p->parent = 0;}\n    for (; i<=m; ++i, ++p) { p->weight= 0;\n\tp->lchild= p->rchild= p->parent = 0; }\n    for (i=n+1; i<=m; ++i) { //建Huffman树\n\t//在HT[1..i-1]找parent为0且权重最小的两个结点(其序号为s1，s2)\n\tSelect(HT, i-1, &s1, &s2); \n\t(HT+s1)->parent = i; (HT+s2)->parent = i;\n\t(HT+i)->lchild = s1; (HT+i)->rchild = s2;\n\t(HT+i)->weight = (HT+s1)->weight+(HT+s2)->weight;\n          }\n     //两种方法获得Huffman编码… …\n18",
    "Huffman编码算法\n//方法1：从叶子到根逆向求每个 字符的Huffman编码\n    HC= (HuffmanCode)malloc( (n+1)*sizeof(char *));\n    //分配存放n个字符编码的头指针向量\n    cd = (char *)malloc (n*sizeof(char)); //存放 编码\n    cd[n-1] = '\\0';\n    for (i=1; i<=n; ++i){ //逐个字符求Huffman编码\n         start = n-1; //编码结束位置\n         for (c= i, f=HT[i].parent; f!=0; c=f, f=HT[f].parent)\n\t  //从叶子到根逆向求编码\n                if (HT[f].lchild == c) cd[--start] = '0';\n                else cd[--start] = '1'; \n        //为第i个字符的编码分配空间\n        HC[i] = (char *)malloc((n-start)*sizeof(char));\n        strcpy(HC[i], &cd[start]);//从cd复制编码到HC\n    }\n    free(cd);\nreturn HC;\n}//HuffmanCoding\n19",
    "//方法2：无栈非递归遍历Huffman树，求Huffman编码\n    HC= (HuffmanCode)malloc( (n+1)*sizeof(char *));\n    cd = (char *)malloc (n*sizeof(char)); \n    q = m; cdlen = 0;\n    for (i=1; i<=m; ++i) (HT+i)->weight = 0; //用作结点状态标志\n    while (q) { //从根出发，遍历Huffman树\n        if ((HT+q)->weight ==0) {(HT+q)->weight = 1; //向左，访问左结点\n              if ((HT+q)->lchild != 0) {q = (HT+q)->lchild; cd[cdlen++] = ‘0’;}\n              else if ((HT+q)->rchild == 0){ //到达叶结点，登记该结点的编码\n                            HC[q] = (char *)malloc((cdlen+1)*sizeof(char));\n                            cd[cdlen] = '\\0'; strcpy(HC[q], cd);   }\n          }\n         else if ((HT+q)->weight == 1) {(HT+q)->weight = 2; //向右访问右结点\n                         if ((HT+q)->rchild != 0) { q = (HT+q)->rchild;  \n                                                               cd[cdlen++] = ‘1’;    }\n                 } else { // (HT+q)->weight == 2，该结点的左右孩子都访问过了 \n                      (HT+q)->weight = 0; q = (HT+q)->parent; --cdlen;//退回父节点\n                       }//else\n    }//while\nreturn HC;  }//HuffmanCoding\n20",
    "void Select(HuffmanTree HT, int i, int *s1, int *s2)\n{HuffmanTree  p;\nint j,min1,min2;\n\nmin1 = MAXVALUE; min2 = MAXVALUE;\nfor (j=1,p=HT+1; j<=i; j++, p++)\n    if(p->parent == 0) {\n        if (p->weight <min1) { \n\tmin2=min1;*s2=*s1; \n\tmin1= p->weight;*s1=j;}\n        else if (p->weight < min2) {\n\tmin2= p->weight;*s2=j; }\n    }\n}\nint main()\n{int w[]={45,13,12,16,9,5}; \n//w存放n个字符的权值，\n//构造Huffman树HT和编码HC\nHuffmanCode HC;\nHC = HuffmanCoding(w,6);\n}\n21",
    "多叉Huffman树\nHuffman树也可以是k叉的，只是在构造k叉Huffman树时需要先进行一些调整\n构造k叉Huffman树：每次选k个权重最小的元素来合成一个新的元素，该元素权重为k个元素权重之和\n当k大于2时，按照这个步骤做下去可能到最后剩下的元素少于k个\n22",
    "二叉树的性质\nn个结点的二叉链表必定存在n+1个空链域\nn个结点有2n个指针；除了根结点，其他结点(共n-1)都有一个双亲结点，即有指针从双亲指向自己，故，剩下的空链域为2n-(n-1)=n+1\ntypedef struct BiTNode { \n    // 结点结构\n    TElemType      data;\n    struct BiTNode  *lchild, *rchild;\n    // 左右孩子指针\n} BiTree;\n23",
    "5. 线索二叉树 (Threaded binary tree)\n二叉树的遍历实际上是将二叉树的非线性结构线性化，使得任一数据元素都有它的直接前驱和直接后继\n为了方便地找到二叉树指定结点在某种线性序列中的直接前驱和直接后继，设计了线索二叉树\n线索：指向该线性序列中数据元素“前驱”和“后继”的指针\n线索二叉树：包含线索的二叉树\n二叉树的线索化：将某种遍历顺序下的前驱、后继关系(线索)记在树的存储结构中\n24",
    "线索二叉树\n先序(DLR)\n123456 \n中序(LDR)\n324165 \n后序(LRD)\n342651\n25",
    "线索二叉树\n以这n+1个lchild 和 rchild 的空闲指针用作 pred 指针和 succ 指针，并增设两个标志 ltag 和 rtag，指明指针是指示孩子还是前驱还是后继线索\n\n\n当ltag (或rtag) = 0，表示lchild(或rchild) 指示左孩子(或右孩子)结点\n当ltag (或rtag) = 1，表示lchild(或rchild) 为前驱(或后继)线索\n26",
    "线索二叉树的表示：线索二叉链表\ntypedef enum { Link, Thread } PointerThr;  \n\t//Link==0，表示是指针，\n\t//Thread==1，表示是线索\ntypedef struct BiThrNod {\n    TElemType        data;\n    struct BiThrNode  *lchild, *rchild; //左右指针\n    PointerThr         ltag, rtag;    //左右标志\n} BiThrNode, *BiThrTree;\n27",
    "二叉树的线索表示\n以中序遍历二叉树：bdaec\n中序线索二叉树：有两个线索处于悬空状态\n一个是树中中序下的第一个结点B的前驱线索\n一个是树中中序下的最后一个结点C的后继线索\n28",
    "线索二叉树的操作\n建立线索二叉树\n遍历线索二叉树\n给定线索二叉树的一个结点，找其后继或前驱 \n\n如何建立线索二叉树？\n在中序遍历过程中修改结点的左、右指针域，以保存当前访问结点的“前驱”和“后继”信息\n遍历过程中，附设指针pre，并始终保持指针pre指向当前访问的、指针p所指结点的前驱\n断点续讲\n29",
    "建立线索二叉树-I\nStatus  InorderThreading( BiThrTree *Thrt, BiThrTree T ) { //Thrt 指向头结点\n  //中序遍历二叉树T，并将其中序线索化\n  Thrt->ltag= Link; Thrt->rtag= Thread;\n  Thrt->rchild = Thrt;//指向自己\n  if (!T)    Thrt->lchild = Thrt; //指向自己\n  else {  Thrt->lchild = T; pre = Thrt;\n              InThreading(T);\n              pre->rchild = Thrt; pre->rtag = Thread;\n              Thrt->rchild = pre; } \n  return OK;\n} // InorderThreading\n30",
    "建立线索二叉树-II\nvoid InThreading(BiThrTree p){\n    if (p) {  InThreading(p->lchild);\n                 if  (!p->lchild) { p->ltag = Thread;  \n\t\t\t\t     p->lchild = pre;}\n                 if  (!pre->rchild) { pre-rtag = Thread; \n\t\t\t\t\tpre->rchild = p;}\n                 pre = p;\n                 InThreading(p->rchild); \n   }\n}//InThreading\n31",
    "在线索链表上进行中序遍历/非递归算法\nvoid InorderTraverse_Thr(BiThrTree T, \n\tvoid (*Visit)(TElemType e)) { //T指向头结点\n  p = T->lchild;       // p指向根结点\n  while ( p != T ) {  // 空树或遍历结束时，p==T\n     while (p->ltag==Link)  p = p->lchild;  // 最左的结点\n     if (!Visit(p->data) ) //访问其左子树为空的结点\n\treturn  ERROR;\n     while (p->rtag==Thread && p->rchild!=T) { //无右子树\n         p = p->rchild;  Visit(p->data);// 访问后继结点\n         }\n     p = p->rchild;          // p进至其右子树根\n  }\n} // InorderTraverse_Thr\n不需要栈！\n32",
    "中序线索二叉树的基本操作-I\n寻找中序遍历下非空树的第一个结点\n左子树上处于“最左下”(没有左子树)的结点\n最左分支的叶结点\n寻找当前结点在中序下的后继\nif (current->rtag ==1) //线索\n    后继为current->rchild\nelse   //current->rtag == 0\n    后继为当前结点右子树\n    中序遍历下的第一个结点\n    即，右子树中最左下的结点\n中序遍历顺序：DBGJEACHKFI\n33",
    "中序线索二叉树的基本操作-II\n寻找当前结点在中序下的前驱\nif (current->ltag == 1)\n 前驱为current->lchild \nelse //current->ltag == 0\n 前驱为当前结点左子树\n 中序下的最后一个结点\n 即，左子树下最右下的结点 \n寻找中序遍历下非空树的最后一个结点\n右子树上处于“最右下”(没有右子树)的结点\n中序遍历顺序：DBGJEACHLKFI\n34",
    "后序线索二叉树的基本操作-I\n寻找当前结点在后序遍历下的后继\nif (current->rtag ==1) //线索\n    后继为current->rchild\nelse   //current->rtag == 0\n   若当前结点为根结点，则无后继\n   若当前结点无右兄弟，则后继为其parent\n   若当前结点有右兄弟，则其后继为右兄弟\n    按后序遍历出的第一个结点\n35",
    "后序线索二叉树上结点的后继\nB的后继：\nC\nC的后继：\nC无右兄弟\nC的后继是D\nD的后继：\nD的右兄弟(G)按后序遍历的第一个结点\nD的后续是E\nF的后继：\nF无右兄弟\nF的后继是G\n后序遍历：ABCDEFGH\n36",
    "后序线索二叉树的基本操作-II\n寻找当前结点在后序下的前驱\nif (current->ltag == 1)\n     前驱为current->lchild \nelse    //current->ltag == 0\n         若当前结点有右孩，则前驱为其右孩\n         (若当前结点有左孩，则)前驱为其左孩\n         \n 寻找后序遍历下非空树的最后一个结点\n  根结点！\n37"
  ],
  "Chapter+6-树与二叉树-Part+3": [
    "第六章 树和二叉树\nPart-III\n1",
    "目录\n基本概念\n二叉树及其存储表示\n二叉树的遍历\nHuffman树\n线索二叉树\n树\n6.1 树的存储表示，树的性质\n6.2 树的遍历\n6.3 (树的变体)并查集及应用\n6.4 (树的应用)求幂集\n6.5 (树的应用)四皇后\n森林\n7.1 存储表示\n7.2 遍历\n2",
    "6.1 树\n树的存储表示\n双亲表示法\n孩子表示法(链表)\n孩子-兄弟表示法\n3",
    "树的双亲表示法\n树的结点：数据元素和其双亲结点的信息\n\n#define MAX_TREE_SIZE  100\ntypedef struct PTNode { //结点结构\n    TElemType  data;\n    int    parent;   // 双亲位置域\n} PTNode; \ntypedef struct { //树结构\n    PTNode  nodes [MAX_TREE_SIZE];\n    int    r, n;   // 根结点的位置和结点个数\n} PTree;\n4",
    "树的双亲表示法\n树中结点的存放顺序一般不做特殊要求，但为了操作实现的方便，有时也会规定结点的存放顺序\n例如，可以规定按树的层次次序安排所有结点\n树的操作\nRoot() //求树的根结点：沿parent找到无双亲的结点\nChild() //求当前结点的最左孩子：遍历整个树\n5",
    "树的孩子表示法\n每个结点的孩子结点形成一个单链表\nn个结点组成线性表\n\n孩子结点结构ChildPtr\n\n\n结点结构CTBox\n\n\n树结构CTree\ntypedef struct CTNode { //孩子结点\n     int          \t     child;\n     struct CTNode *next;\n} *ChildPtr;\n\ntypedef struct { //结点结构\n     TElemType    data;\n     int parent; //指向双亲结点\n     ChildPtr         firstchild;\n     //孩子链的头指针\n} CTBox;\n\ntypedef struct { //树结构\n    CTBox  nodes[MAX_TREE_SIZE];\n    int   n, r; // 结点数和根结点的位置\n} CTree;\ndata   firstchild\n6",
    "树的孩子表示法(链表)\n无序树时，链表中各个结点顺序任意\n有序树时，必须自左向右链接各个孩子结点\n树的操作：\n对涉及孩子的操作比较方便\n对涉及双亲的操作不方便\n7",
    "树的孩子-兄弟表示法\ntypedef struct CSNode{\n     TElemType    data;\n     struct CSNode *parent; //指向双亲结点\n     struct CSNode *firstchild, *nextsibling;\n} CSNode, *CSTree;\n\nfirstChild 指向该结点的第一个孩子结点\n无序树时，可任意指定一个结点为第一个孩子\nnextSibling 指向该结点的下一个兄弟\n任一结点在存储时总是有顺序的\n若想找某结点的所有孩子，可先找firstChild，再反复用 nextSibling 沿链扫描\n8",
    "树的孩子-兄弟表示法\n根结点的\n右子树\n一定为空\n给定一棵树，可以找到唯一的一棵二叉树与之对应\n9",
    "(存储态的)二叉树转换成(逻辑态的)树\n10",
    "树的性质/树的结点数/树的计数\n11",
    "二叉树的计数\n12",
    "6.2 树的遍历\n深度优先遍历\n先根次序遍历：若树不空，则先访问根节点，然后依次先根遍历各棵子树\n后根次序遍历：若树不空，则先依次后根遍历各棵子树，然后访问根节点\n广度优先遍历/层次遍历\n\n\n\n\n\n                                            树的二叉树表示\n13",
    "树的先根和后根遍历\nvoid preorder(CSNode *p){CSNode *t;\nif(p){\n    … …//访问该结点\n    for(t=p->firstchild; t!=NULL; t=t->nextsibling)\n    preorder(t);\n    }\n}\nvoid postorder(CSNode *p){CSNode *t;\nif(p){\n    for(t=p->firstchild; t!=NULL; t=t->nextsibling)\n    postorder(t);\n     … …//访问该结点\n    }\n}\n14",
    "树的先根次序遍历\n当树非空时\n访问根结点\n依次先根遍历根的各棵子树\n\n树先根遍历 ABEFCDG\n对应二叉树先序遍历 ABEFCDG\n树的先根遍历结果与其对应二叉树\n表示的先序遍历结果相同\n树的先根遍历可以借助对应二叉树的先序遍历算法实现\n15",
    "树的后根次序遍历\n当树非空时\n依次后根遍历根的各棵子树\n访问根结点\n\n树后根遍历 EFBCGDA\n对应二叉树中序遍历 EFBCGDA\n树的后根遍历结果与其对应二叉树\n表示的中序遍历结果相同\n树的后根遍历可以借助对应二叉树的中序遍历算法实现\n16",
    "6.3 并查集及其应用\n并查集(union-find set, disjoint set)：一种集合，每个元素只属于一个子集合，不同子集合中的元素不相交\n形成过程：\n每个元素各自形成一个子集合\n若元素x和元素y属于一个子集合，那么将x所在子集合和y所在子集合进行合并\n对该集合的基本操作有：查找一个元素在哪个子集合，判断两个元素是不是在一个子集合中，合并两个子集合\nMFSet *InitMFSet(n)//初始化为n个只有一个元素的子集合\nint FindMFSet (s, x) //在s中查找集合元素x所在的子集合\nStatus MergeMFSet (*s, root1,root2)//当root1和root2不相交时，把子集合root1并入root2中\n17",
    "并查集的存储表示\n并查集：森林/多颗树\n用一颗(双亲表示法表示的)树表示一个子集合\n树的每一个结点代表集合的一个元素\n好处/方便之处\n用树的根标识一个子集合\n很容易实现集合合并操作\ntypedef struct PTNode{  \n     DataType data;  \n     int parent;  //指示双亲位置  \n} PTNode;  \ntypedef struct{  \n   PTNode   nodes[MAX_TREE_SIZE]; \n   int n; //结点数  \n} PTree;  \ntypedef  PTree   MFSet;\n18",
    "并查集例子\n集合S：{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n3个不相交子集/并查集：{0 , 6 , 7 , 8}, {1 , 4 , 9}, {2 , 3 , 5}\n并查集的树表示\n\n\n\n并查集的存储表示\nparent域：\n== -1: 树根\n >= 0: 父所在的数组位置\n19\nparent",
    "并查集的操作\n// Sj=Si∪Sj  \nStatus MergeMFSet(MFSet *S, int i, int j) {\n    //S->nodes[i]和S->nodes[j]分别为S的互不相交的\n    //两个子集Si和Sj的根结点\n    if( i<0 || i>=S->n || j<0 || j>=S->n)   return ERROR;  \n    S->nodes[i].parent = j;  \n    return OK; \n}\n\n//确定集合S中元素i所属子集的根  \nint FindMFSet(MFSet S, int i){  \n    if  (i<1|| i>S.n)   return ERROR;    \n    for(j=i; S.nodes[j].parent>=0; j=S.nodes[j].parent) ;  \n    return j；\n}\nFindMFSet的时间复杂度为O(d) ，其中d是树的深度，其值和树的形成过程有关\nn个元素的集合，构建并查集，在最坏情况下，即从n棵单元素树的森林变成单支树，全部操作(FindMFSet(S,i) + MergeMFSet(*S,i,j))的时间复杂度是O(n2)\n20\nStatus MergeMFSet (*s, root1,root2)//当root1和root2不相交时，把子集合root1并入root2中",
    "算法改进\n加权合并：若树i结点数少于树j结点数，将j作为i的父结点，否则将i作为j的父结点\n修改相应的存储结构：令根结点的parent域存储子集中所含元素数目的负值\nStatus MixMFSet(MFSet *S, int i,  int j) {  \n    //S->nodes[i]、S->nodes[j] 为S互不相交的两个子集Si和Sj的根结点\n    if (i<0 || i>=S->n || j<0 || j>=S->n) return ERROR;  \n    if(S->nodes[i].parent>=S->nodes[j].parent) {  //Si所含元素不比Sj多 \n         S->nodes[j].parent += S->nodes[i].parent;\n         S->nodes[i].parent  =  j; //i所在集合合并到j所在集合\n    }\n    else{  \n\tS->nodes[i].parent += S->nodes[j].parent; \n            \tS->nodes[j].parent  = i;  \n    \t}\n    return OK;  \n}\n21",
    "算法改进\n压缩路径：当所需确定的元素i不在树的第二层时，可通过 “压缩路径”功能缩短元素到达根结点的路径\n\nint FixMFSet(MFSet *S, int i) {  int j,k,t; //确定i所在子集，\n   //将从i至根路径上所有结点变为根的孩子结点\n    if(i<0 || i=>S->n) return ERROR;   \n    //寻找i所在树的根，记录在j\n    for(j=i;  S->nodes[j].parent>=0; j=S->nodes[j].parent) ;  \n    for(k=i; k !=j; k=t) {  \n\t//将从i到根沿路结点的双亲都指向根\n            \tt=S->nodes[k].parent;  \n\tS->nodes[k].parent=j;  \n           }\nreturn j; \n}\nFixMFSet(S,7)\n22",
    "并查集\n例子\n23\n形成两个并查集\n两个并查集合并",
    "并查集的应用\n判断和构造等价类\n判断和构造图的连通分量\n求解最小生成树(Kruskal算法的实现)\n病毒溯源\n每个人独立集合，A感染，B被A感染，那么AB是一个源，合并AB成一个集合，后续问B是被谁感染的？\n一个城市中有不同的犯罪团伙，请帮助警察判断任意两起案件是否是同一个犯罪团伙所为，警察所获得的信息是：到目前为止有N起案件，每起案件是由某个团伙所为\n24",
    "等价类\n等价类是一个集合，该集合元素都满足等价关系\n等价关系是集合上的一个自反、对称、传递的关系\n假定有n个元素的集合U，另有一个U上关系 R∈UXU，关系R是一个等价关系，当且仅当如下条件为真时成立：\n对于所有的a，有(a,a)∈R，即关系是自反的\n如果有 (b,a)∈R时，则有(a,b)∈R，即关系是对称的\n若(a,b)∈R且(b,c)∈R，则有(a,c)∈R，即关系是传递的\n\n若R是集合S上的等价关系，那么由R可以产生这个集合S的一个唯一的划分S1, S2, ….，这些集合互不相交，其并集为S\n25",
    "划分等价类的算法思想\n26",
    "6.4 n个元素的幂集\n一个集合的幂集是由该集合的所有子集所组成的集合\n\n例如：集合{a, b, c}的幂集为{ {a, b, c}, {a , b}, {a , c}, {b, c},{a}, {b}, {c}, {}}\n4种集合：\n空集\n集合中的一个元素组成的集合\n集合中的任意两个元素组成的集合\n集合中的三个元素组成的集合，就是它本身\n27",
    "n个元素的幂集\n集合中的每个元素有两种状态：在幂集的元素集合中，不在幂集元素集合中\n可以用一棵二叉树表示幂集生成的过程\n先序遍历该状态树即可求得幂集元素\n在叶结点打印出幂集元素\n28",
    "n个元素的幂集\n//已对集合中第i个元素进行了取舍\nvoid GetPowerSet(int i, SqList *ASet, SqList *BSet ) {\nElemType x;int k;\nif (i==ASet->length) {… … }//输出 B;\nelse {\n    x=ASet->elem[i];//取ASet的第i+1个元素\n    k=BSet->length;\n    ListInsert_Sq(BSet, k+1,x);//插入BSet\n    GetPowerSet(i+1,ASet,BSet); //B中含第i+1个元素\n    ListDelete_Sq(BSet,k+1,&x);  //在B中删除该元素\n    GetPowerSet(i+1, ASet, BSet); //B中无第i+1个元素\n    }\n}//GetPowerSet\n29",
    "6.5 四皇后问题\n在4×4的国际象棋棋盘上，如何放置4个皇后，使得没有两个皇后在同一行或同一列或同一对角线上？\n30",
    "四皇后问题-棋盘状态树\n布局用四元组(ijkl)表示\n(ijkl)表示4个皇后分别在第1,2,3,4行的第i,j,k,l列，用*表示所在列数不确定\n布局的生成过程形成一颗树\n\n\n\n\n\n\n对上述树进行先根遍历，并在遍历过程中裁剪掉那些不满足条件的分支\n树的叶子结点总数：\n4*3*2*1=24\n31",
    "四皇后问题\nvoid Queens(int chess[],int i){ int j,k;\nif(i==CHESSBOARD_SIZE){ … … //输出棋盘的当前布局\n    return; }\nfor(j=0;j<CHESSBOARD_SIZE;j++){\n    chess[i]=j; //在第 i 行第 j 列放置一个棋子\n    for(k=0; k<i &&  (chess[i]!=chess[k] && \n\ti-chess[i] !=k-chess[k] && i+chess[i]!=k+chess[k]);\n\tk++) ;\n    if (k==i) //当前布局合法\n        Queens(chess,i+1);\n    else //当前布局不合法\n        chess[i]= -1; //移去第 i 行第 j 列的棋子\n    }\n}\n32",
    "四皇后问题\n进入Queens函数时，在n×n棋盘前i-1行已放置了合法的棋子\nint chess[CHESSBOARD_SIZE],i;\nfor(i=0;i<CHESSBOARD_SIZE; i++) chess[i]= -1; //未放置棋子\nchess[0]=i; Queens(chess,1);\n现从第 i 行起继续为后续棋子选择满足约束条件的位置\n在树的深度优先查找时，判断结点是否满足约束条件，若不符合，则剪枝掉该结点的子孙\n约束条件(函数)：任何2个皇后不放在同一行或同一列或同一斜线上\n当求得一个合法布局时，输出之\n\n八皇后问题/1850年高斯给出了76个解：92个解\n33",
    "回溯算法(Backtracking algorithm)\n回溯算法是一种“穷举”法，也叫试探法，是一种系统地搜索问题的解的方法\n用回溯算法解决问题的一般步骤：\n针对所给问题，定义问题的解空间，它包含问题的所有(最优)解\n将解空间看成一颗树结构，使得能用回溯法方便地搜索整个解空间 \n以先根遍历方式搜索解空间，并且在搜索过程中用约束函数剪枝解空间，避免无效搜索\n问题的解空间通常是在搜索问题解的过程中动态产生的，这是回溯算法的一个重要特性\n例子：迷宫寻路，八皇后\n34",
    "7.1 森林\n森林的二叉树表示法\n将森林 F={T1, T2, …Tm}，其中T1=（root, t11, t12,…, t1m)   表示成  二叉树B=(root, LB, RB)\n若 F = Φ，则 B = Φ;\n否则，由 ROOT( B) = ROOT(T1)\n            由 (t11, t12,…, t1m) 对应得到 LB\n            由 (T2, T3,…, Tn ) 对应得到 RB\n\n将森林转换为二叉树的步骤：\n先把每棵树转换为二叉树\n第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子结点，用线连接起来\n将所有的二叉树连接起来后得到的二叉树就是由森林转换得到的二叉树\n35",
    "森林转换成二叉树\n36",
    "二叉树转换成森林\n由二叉树B=(root, LB, RB)转换为森林F={T1, T2, …Tm}的转换规则为：\n若 B = Φ, 则 F = Φ\n否则，由 ROOT(B)=ROOT(T1)\n            由LB 对应得到 (t11, t12,…, t1m)，\n\t\t注：T1 = (ROOT(T1), t11, t12 ,…, t1m)\n            由RB 对应得到 (T2, T3, …, Tn)\n\n二叉树转换为森林的步骤：\n先把根结点与右孩子结点的连线删除，得到分离的二叉树\n把分离后的二叉树转换为树\n若某结点的左孩子结点存在，将左孩子结点的右孩子结点、右孩子结点的右孩子结点……都作为该结点的孩子结点，将该结点与这些右孩子结点用线连接起来\n删除原二叉树中所有结点与其右孩子结点的连线\n37",
    "思考题\n设森林F中有4棵树，第1、2、3、4棵树的结点个数分别为n1、n2、n3、n4，当把森林F转换成一棵二叉树后，根结点的右子树中有多少结点？\nn1-1\n\nn1+n2+n3\n\nn2+n3+n4\n\nn1\n38",
    "思考题\n设F是一个森林，B是由F转换得到的二叉树，F中有n个非叶结点，那么B中右指针为空的结点有多少个？\nn-1\n   n个非叶结点对应n个兄弟链，每个链有一个右空结点\nn\n\nn+1\n\nn+2\n39",
    "7.2 森林的遍历\n森林由三部分构成：\n森林中第一棵树的根节点\n森林中第一棵树的子树森林\n森林中其他树构成的森林\n40\n先序遍历：ABCDEFGHJI\n中序遍历：BCDAFEJHIG",
    "森林的遍历\n森林的先序遍历\n若森林不空，则：\n访问森林中第一棵树的根节点；\n先序遍历森林中第一棵树的子树森林\n先序遍历森林中(除第一棵树之外)其余树构成的森林\n对其对应的二叉树进行先序遍历\n森林的中序遍历\n若森林不空，则：\n中序遍历森林中第一棵树的根节点子树森林\n访问森林中第一棵树的根节点；\n中序遍历森林中(除第一棵树之外)其余树构成的森林\n对其对应的二叉树进行中序遍历\n41",
    "总结\n熟练掌握二叉树的结构特性，了解相应的证明方法\n熟悉二叉树的各种存储结构的特点及适用范围\n掌握二叉树各种遍历策略的递归/非递归算法，灵活运用遍历算法实现二叉树的其它操作\n遍历二叉树是二叉树各种操作的基础\n实现二叉树遍历的具体算法与所采用的存储结构有关\n42",
    "总结\n熟练掌握二叉树的线索化过程以及在中序线索化树上找给定结点的前驱和后继的方法\n二叉树线索化的实质是建立结点与其在相应序列中的前驱或后继之间的直接联系\n二叉树的线索化过程是基于对二叉树进行遍历，而线索二叉树上的线索又为相应的遍历提供了方便\n了解最优树的特性，掌握建立最优树和Huffman编码的方法\n熟悉树的各种存储结构及其特点，掌握树和森林与二叉树的转换方法\n学会编写实现树的各种操作的算法\n掌握并查集的实现和应用\n43\n断点续讲"
  ],
  "Chapter+7-图-Part+1": [
    "第7章 图\nPart I\n1",
    "目录\n基本概念\n图的存储结构\n邻接矩阵/数组表示，邻接表表示\n(有向图)十字链表，(无向图)邻接多重表\n访问图的顶点：深度优先遍历，广度优先遍历\n排序(有向)图的顶点：DAG/AOV网的拓扑排序\n图的连通性\n无向图的生成森林\n有向图的强连通分量\n重连通分量和关节点\n(连通带权图的)最小生成树：Prim算法，Kruskal算法\n(带权连通)图的路径\n关键路径/最长路径：有向无环带权图/AOE网\n最短路径：Dijkstra算法，Floyd算法\n2",
    "1. 图 (Graph)\n线性结构：除第一个和最后一个元素外，任何一个元素都有唯一的一个直接前驱和直接后继\n非线性结构\n树结构：每个数据元素有且仅有一个直接前趋(即它的上层结点) ，可以有0-多个直接后继(即它的下层结点) ，数据元素之间有明显的层次关系\n图结构：任意两个元素之间可能存在关系，图中任意元素之间都可能相关；元素之间的关系可以是任意的\n图是二元关系的扩展/Graphs are extensions of relations",
    "术语-图、子图\n图(graph)：\n顶点(vertex)：表示数据元素\n边(edge) ：表示两个顶点v和w之间存在一个关系，用顶点对<v,w>表示\nG=(V, E)，V是顶点集，为有穷非空集合，E是边集，为有穷集合\n子图(subgraph)和生成子图(spanning subgraph)\n设有图G=(V, E)和G’=(V’, E’)，若V’V且E’ E，则称图G’是G的子图；若V’=V且E’ E，则称图G’是G的一个生成子图\n15\n9\n7\n21\n11\n3\n2\n11\n3\n2",
    "术语-图的分类\n简单图(simple graph)：每条边连接两个不同的顶点(即无自环)且没有两条不同的边连接一对相同顶点(即无重边)的图\n完全图(complete graph)：在每对不同顶点之间恰好有一条边的简单图\n多重图(multigraph)：有多重边连接到同一对顶点的图\n5",
    "术语-图的分类\n根据图的边将图分为有向图和无向图\n有向图(DG, directed graph, digraph)：顶点对<v,w>的v和w之间是有序的\n在有向图中，若从顶点v到顶点w有一条有向边(directed edge)/弧(arc)，那么，v称为弧尾(tail)或初始点(initial node)，w称为弧头(head)或终点(terminal node) \n无向图(UDG, undirected graph, undigraph)：顶点对<v,w>的v和w之间是无序的，即：若有(v, w)ϵE，则必有 (w, v)ϵ E\n6",
    "术语-图的分类",
    "术语-权\n权重(weight)：与图的边/弧相关的数\n可以表示从一个顶点到另一个顶点的距离或耗费\n带权图或网(network) ：图上每个边(或弧)都附加一个权值\n8\n计算机网络\n复杂网络(Complex Network)：将统计物理学思想引入图论\n随机网络\n小世界网络\n无尺度网络\n神经网络",
    "网络的实例\n9",
    "图的表征学习(Representation learning on graphs)\n10",
    "术语-路径(path)\n对无向图G=(V, E)，若从顶点vi经过若干条边能到达vj，称顶点vi和vj是连通的，又称顶点vi到vj有路径\n对有向图G=(V, E)，从顶点vi到vj有有向路径，指的是从顶点vi经过若干条有向边(弧)能到达vj\n路径上边或有向边(弧)的数目称为该路径的长度\n\n从顶点vi到vj的路径不唯一\n两种路径表示法：边/弧的序列，顶点序列\nPath=ei0ei1…eim, eijE, j=1,2, …,m\nPath=vi0vi1…vim, vijV且(vij-1, vij)E,  j=1,2, …,m",
    "术语-路径(path)\n在一条路径中，若没有重复相同的顶点，该路径称为简单路径 (simple path)\n第一个顶点和最后一个顶点相同的路径称为回路(circuit, 环cycle) \n在一个回路中，若除第一个与最后一个顶点之外，其余顶点不重复出现的回路称为简单回路(简单环)\n12",
    "术语-连通图\n对无向图G=(V, E)，若vi，vj V，vi和vj都是连通的(指从vi到vj有路径存在)，则称图G是连通图(connected graph)，否则称为非连通图\n连通分量：非连通的无向图中的极大连通子图\n极大连通子图：在非连通的无向图中，相连通的顶点加上依附于这些顶点的边\n极小连通子图(minimal connected subgraph)：无向连通图的生成树\n生成：覆盖图上所有顶点\n树：连通各个顶点但无环。加边的话，出现单环，删边的话，各个顶点不连通\n13",
    "术语-连通图\n对有向图G=(V, E)，若vi ，vj V，都有以vi为起点， vj 为终点以及以vj为起点，vi为终点的有向路径，称图G是强连通图 (strongly connected graph)，否则称为非强连通图\n强连通分量：非强连通的有向图中的极大连通子图\n有向图的生成森林：由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交有向树的弧\n有向树是只有一个顶点的入度为0 ，其余顶点的入度均为1的有向图\n14",
    "术语-重连通图\n若从一个连通图中删去任何一个顶点及其相关联的边，它仍为一个连通图的话，则该连通图被称为重(双)连通图(biconnected graph)\n若连通图中的某个顶点和其相关联的边被删去之后，该连通图被分割成两个或两个以上的连通分量，则称此顶点为关节点(articulation point)/割点(cut point)\n没有关节点的连通图为重连通图\n15",
    "术语-度\n对于无向图G=(V, E)：\n若边(v,w)E，则称顶点v和w 互为邻接点，即v和w相邻(adjacent to)，而边(v,w)依附于(incident with) 顶点v和w \n viV，依附于vi的边的数目称为顶点vi的度(degree)，记为TD(vi)\n握手定理/Handshaking theorem：所有顶点的度的和是图中边的2倍，即：∑TD(vi)=2e, i=1, 2, …, n，e为图的边数\n定理：在任何图中，所有度数之和必为偶数，度数为奇数的顶点必定是偶数个\n推论：若图Ｇ有n个顶点，n+1条边，则Ｇ中至少有一个顶点的度数大于等于3",
    "术语-度\n对于有向图G=(V, E)：\n若有向弧<v,w>E，则称：顶点v 邻接到顶点w，顶点w 邻接自顶点v ，弧<v,w> 与顶点v、w 相关联\n若vi V，\n以vi作为起点的有向边(弧)的数目称为顶点vi的出度(outdegree)，记为OD(vi) \n以vi作为终点的有向边(弧)的数目称为顶点vi的入度(indegree)，记为ID(vi) \n顶点vi的出度与入度之和称为vi的度，记为TD(vi)，即，TD(vi)=OD(vi)+ID(vi) \n握手定理：所有顶点的度的和是图中边的2倍\n定理：在任何有向图中，所有顶点的入度之和等于所有顶点的出度之和",
    "例子\n无向图：\nTD(B)=3，TD(A)=2\n有向图：\nOD(B)=1，ID(B) =2，\nTD(B) =3\n18",
    "图的应用实例：城市公交\nBus stop graph/公交站点图：\n顶点是公交站\n边表示两公交站是一趟公交线的两个连续的站\n图上的一条路径表示的是坐公交线能到达的地方\nBus transfer graph/公交换乘图：\n顶点是公交站\n边表示有直接的公交线路经过这两个公交站\n图上的一条路径表示两个地方可以通过换乘到达\nBus line graph/公交线路图：\n顶点是公交线路\n边表示两条线路有公共的公交站\n图上的一条路径表示一条公交线可以通过换乘到达另一条公交线(但不知道在哪里换乘)\n19",
    "图的应用实例\nAOV(Activity on Vertex)：用顶点表示活动，用弧表示活动之间的优先关系\n结点的排序/拓扑排序\n\n\nAOE(Activity on Edge)：以顶点表示事件，以有向边表示活动，边上的权值表示活动的开销\n关键路径/最长路径\n20",
    "图的设计：图的基本操作\n图G，顶点v，w\nCreateGraph(*G, V, VR);  //按顶点集V和弧集VR构造图G\nListGraph(*G); \t//输出所有边和顶点的信息\nDestroyGraph(*G);\t//销毁图G\nLocateVex(*G, u);  \t//返回图G中与u有相同特征的顶点\n先决条件：该顶点u属于图G的顶点集合\n操作结果：从顶点的数据值找出该顶点的顶点号，如果查找失败，返回-1\n内部实现：如何指定比较方法？\nGetVex(*G, v);     \t//返回图G中的顶点v的值\nPutVex(*G, v, value); \t//对图G的顶点v赋值value\nFirstAdjVex(*G,v); \t//返回顶点v的第一个邻接顶点\nNextAdjVex(*G,v, w); //返回顶点v的(相对于w的)下一个邻接顶点\nInsertVex(*G,v); \t//在图G中添加顶点v\nDeleteVex(*G,v); \t//在图G中删除顶点v以及相关的弧\nInsertArc(*G,v,w);\t//在图G中增添弧<v, w>\nDeleteArc(*G,v,w); \t//在图G中删除弧<v, w>",
    "图的设计：图的基本操作\n22",
    "图的设计：图的基本操作\n//对图G进行深度优先遍历\nDFSTraverse(*G, Visit()); \n//对图G进行广度优先遍历\nBFSTraverse(*G, Visit()); \n先决条件：图G存在，Visit是应用于顶点的函数\n操作结果：对图G进行广度优先遍历(每个顶点被访问且只访问一次)，对每个顶点调用Visit一次且仅一次\n23",
    "2. 图的存储结构\n顺序存储结构？\n因为图的任意顶点之间都可能存在联系，无法以数据元素在存储区中的物理位置来表示元素之间的关系\n用二维数组表示顶点之间的关系\n链式存储结构？\n由于图中顶点的度不一样，若按度数最大的顶点设计结构，则会浪费很多存储单元，反之按每个顶点自己的度设计不同的结构，又会影响操作\n图的常用的存储结构有：数组(邻接矩阵)、邻接表、十字链表、邻接多重表\n邻接矩阵\n邻接表\n十字链表\n邻接多重表",
    "2.1 数组(邻接矩阵，adjacency matrix)表示法\n对于有n个顶点的图：\n用一维数组vexs[n]存储顶点信息\n用二维数组A[n][n]存储顶点之间关系的信息",
    "无向图：无权图的数组表示\n矩阵的元素：\nA    B     C    D    E     F",
    "无向图：带权图的数组表示\n矩阵的元素：\n无向图的邻接矩阵是n阶对称方阵\n对于顶点vi，其度数是第i行(或第i列)的非0元素的个数\n无向图的边数是上(或下)三角形矩阵中非0元素个数",
    "有向图：无权图的邻接矩阵表示\n矩阵元素：\n28\n有向无权图的数组存储",
    "有向图：带权图的邻接矩阵表示\n矩阵的元素：\n带权有向图的数组存储\n对于顶点vi，第i行的非0元素的个数是其出度OD(vi)；第i列的非0元素的个数是其入度ID(vi) \n邻接矩阵中非0元素的个数就是图的弧的数目",
    "图的数组表示\n//图的种类：UDG无向图，DG有向图，UDN无向网，DN有向网\n#define MaxVertexNum 30\ntypedef enum {UDG, DG, UDN, DN} GraphKind;\ntypedef struct ArcCell {\n\tVRType adj; //顶点关系类型：w/1/0\n\tInfoType *info;\n }ArcCell, AdjMatrix[MaxVertexNum][MaxVertexNum];\ntypedef struct{\n\t int vernum,arcnum; //图的顶点数和弧数\n\tGraphKind kind; \n\tVertexType vexs[MaxVertexNum]; //顶点向量\n\tAdjMatrix arcs; //邻接矩阵\n} MGraph; \n\ntypedef struct{\n    int vexnum,arcnum; \t//顶点数，边数\n    GraphKind kind; \t//图的种类\n    char vexs[Max];\t//存放顶点信息\n    int A[Max][Max];\t//存放边的信息\n} MGraph;\n30",
    "采用数组构造无向图\nvoid CreateGraph(MGraph *g) { int i,j,k;\nprintf(\"Input: Vex Num & Arc Num & Arc Kind\\n\");\nscanf(\"%d %d %d\",&g->vexnum,&g->arcnum,&k);\nswitch (k) { \n\tcase 0:     g->kind=UDG;break;\n\tcase 1:     g->kind=DG; break; }\nfor(k=0;k<g->vexnum;k++)     g->vexs[k]='A'+k;\nfor(i=0;i<g->vexnum;i++)\n    for(j=0;j<g->vexnum;j++)\n    g->A[i][j] = 0; // 初始化邻接矩阵\nprintf(\"Input: %d edges: \\n\",g->arcnum);\nfor(k=0;k<g->arcnum;k++) {\n    scanf(\"%d %d\",&i,&j);\n    g->A[i][j]=1;\n    if(g->kind==UDG) g->A[j][i]=1; //无向图时，邻接矩阵是对称的\n    }\n}\n31\n7.2",
    "输出无向图\nvoid ListGraph(MGraph *g) {\nint i,j;\nfor(i=0;i<g->vexnum;i++) {\n    printf(\"%6c---\",g->vexs[i]);\n    for(j=0;j<g->vexnum;j++)\n        printf(\"%4d\",g->A[i][j]);\n    printf(\"\\n\");\n    }\n}\n32",
    "2.2邻接表(Adjacency List)法\n为图的每个顶点建立一个单链表：第i个单链表表示依附于顶点Vi的边\n若是有向图，则为 以顶点Vi为尾的弧\n每一个单链表设一个表头结点：\n数据域(data) 存储顶点名 Vi 或其他信息，链域(first)指向链表中的一个结点(称：表结点)\n所有表头结点用一个向量以顺序结构形式存储，以便随机访问任意顶点的链表：表头向量的下标指示顶点的序号\n表结点：\n邻接点域(adjvex)指示与顶点Vi邻接的顶点在图中的位置(顶点编号)\n数据域(info)存储和边或弧相关的信息如权值等\n链域(next)指向下一个与顶点Vi邻接的表结点\n邻接表的结点结构",
    "邻接表的实现\n#define MAX_VERTEX_NUM 30\ntypedef char ElemType;\ntypedef struct node {\n    int vindex; \t//邻接点在表头结点数组中的位置(下标)\n    struct node *next; //指向下一个表结点\n} NodeLink; // 表结点类型定义\n\ntypedef struct {\n    // 图的顶点数、边数、种类标志\n    int vexnum,edgenum,kind; \n    struct {\n        ElemType vertex;\n        NodeLink *first;// 指向第一个表结点\n       } v[MAX_VERTEX_NUM];\n} AGraph;",
    "例子：无向图的邻接表表示\nv1\nv2\nv3\nv4\nv5\n无向边被重复存储\n邻接多重表\n如何改进？",
    "例子：有向图的邻接表表示\n为求顶点的入度，必须遍历整个邻接表\n为求顶点的出度，必须遍历整个邻接表",
    "邻接表的特点\n表头向量中，每个分量就是一个单链表的表头结点，分量个数就是图中的顶点数目\n在邻接表上容易找出任一顶点的第一个邻接点和下一个邻接点\n在无向图，顶点Vi的度是第i个链表的结点数\n对有向图，可以建立(正)邻接表或逆邻接表\n在有向图的(正)邻接表(或逆邻接表)中，第i个链表中的结点数是顶点Vi的出 (或入)度；求入 (或出)度，须遍历整个邻接表\n在边或弧稀疏的条件下，用邻接表表示比用邻接矩阵表示节省存储空间",
    "采用邻接表构造无向图\nvoid CreateGraph(AGraph *g,int n,int m)\n{int i,e=0; NodeLink *p,*q,*s; char x,y;\ng->vexnum=n; g->kind=m;\nfor(i=0;i<n;i++) {//初始化邻接表\n    g->v[i].vertex = 'A'+i; \n    g->v[i].first=NULL;}\nprintf(\"Input edges x-->y:\");  scanf(\"%c%c\",&x,&y);\nwhile(x!='X' && y!='X'){ e++;\n    //生成表结点并插入邻接表\n    s=(NodeLink *)malloc(sizeof(NodeLink));\n    s->vindex= y-'A';\n    if(g->v[x-'A'].first == NULL) { \n        g->v[x-'A'].first =s;  s->next = NULL; }\n    else {\n        p=g->v[x-'A'].first; q=p->next;\n        while (q!=NULL){\n            p=q;q=q->next;  }\n        p->next=s;s->next=q;\n    }\nif(!g->kind){ //无向图\n    s=(NodeLink *)malloc(sizeof(NodeLink));\n    s->vindex = x-'A';\n    if(g->v[y-'A'].first == NULL) {\n        g->v[y-'A'].first =s;s->next = NULL;}\n    else {\n        p=g->v[y-'A'].first; q=p->next;\n        while(q!=NULL) {p=q;q=q->next;}\n        p->next =s;s->next=q;\n        }\n}\nscanf(\" %c%c\",&x,&y);\n}\ng->edgenum =e;\n}\n38",
    "输出无向图\nvoid ListGraph(AGraph *g) {\nint i; NodeLink *p;\nfor(i=0;i<g->vexnum;i++){\n    printf(\"%d:%c--->\",i,g->v[i].vertex);\n    p=g->v[i].first;\n    while(p) {\n        printf(\"%3d\",p->vindex);\n        p=p->next;}\n    printf(\"\\n\");\n    }\n}\n39",
    "图的顶点定位\n//确定一个顶点在v数组中的位置\nint LocateVex(AGraph *g,ElemType u){\nint k;\nfor(k=0;k<g->vexnum;k++)\n    if (g->v[k].vertex == u) return k;\nreturn -1; //图中无此顶点\n}",
    "定位图的邻接顶点\n//返回顶点x的第一个邻接顶点\nint FirstAdjVex(AGraph *g, int x){\n\tNodeLink *p;\n\tp=g->v[x].first;\n\tif(p) return p->vindex;\n\telse return  -1;\n}\n\n//返回顶点x的(相对于y的)下一个邻接顶点\nint NextAdjVex(AGraph *g, int x, int y){\n\tif (x== -1) return -1;\n\tNodeLink *p=g->v[x].first;\n\twhile (p!=NULL && p->vindex !=y) p=p->next;\n\tif(p!=NULL && p->next!=NULL) return p->next->vindex;\n\treturn -1;\n}\n41",
    "邻接矩阵 vs. 邻接表\n邻接矩阵适用场合：\n图的规模固定\n稠密图\n经常检测边的存在\nO(1)\n经常做边的插入/删除\n邻接表适用场合：\n顶点数目不确定\n稀疏图(边数 << 顶点的平方)\n检测弧/边的存在，需要O(e)\n经常计算顶点的度数\n经常做遍历\n42",
    "2.3 十字链表 (Orthogonal linked list) 法\n每个顶点对应一个结点：每条弧的弧头结点和弧尾结点都存放在链表中\n\n\n\n\n每条弧对应一个结点\n43\n指向以该顶点为弧头的第一个弧结点\n指向以该顶点为弧尾的第一个弧结点\ndata\nfirstin\nfirstout\n指向下一个有相同弧尾的弧结点\n指向下一个有相同弧头的弧结点\ntailvex\nheadvex\nhlink\ntlink\ninfo",
    "十字链表的实现\n#define MAX_VERTEX_NUM  30 //最大顶点数\ntypedef char ElemType;\ntypedef struct ArcBox {\n    int  tailvex, headvex;//尾结点和头结点在图中的位置\n    //InfoType    info;   \t// 与弧相关的信息 如权值\n    struct ArcBox *hlink,\n                  \t*tlink; \t//分别链接弧头相同和弧尾相同的弧\n} ArcNode; //弧结点\ntypedef struct VexNode {\n    ElemType  data;    \t// 顶点信息\n    ArcBox  *firstin,\n\t    *firstout; \t//分别指向该顶点第一条入弧和出弧\n} VexNode;//顶点结点\ntypedef struct {\n    int vexnum, arcnum;\n    VexNode  xlist[MAX_VERTEX_NUM];\n} OLGraph;",
    "有向图的十字链表结构\n例子：有向图的十字链表表示\n从一个顶点结点的firstout出发，沿弧结点的tlink指针构成了正邻接表的链表结构\n从一个顶点结点的firstin出发，沿弧结点的hlink指针构成了逆邻接表的链表结构\nfirstin\nfirstout\nhlink\ntlink",
    "例子：有向图的十字链表表示\n46\n0  \n1  \n2\n∧\nfirstin\nfirstout\nhlink\ntlink",
    "采用十字链表构造有向图\nvoid CreateGraph(OLGraph *g) { // G.kind = DG\nint i,j,k; char v1,v2; struct ArcBox *p;\nscanf(\"%d %d\",&g->vexnum, &g->arcnum);\nfor(i=0; i<g->vexnum; ++i) { //构造表头向量\n         g->xlist[i].data='A'+i;    //设置顶点值\n         g->xlist[i].firstin = g->xlist[i].firstout = NULL;\n         }\nfor(k=0; k<g->arcnum; ++k) { //输入各弧并构造十字链表\n        scanf(\" %c%c\",&v1, &v2); //输入一条弧的始点和终点\n        i=LocateVex(g,v1); j=LocateVex(g,v2); //确定v1和v2在g中位置\n        p=(ArcBox *) malloc (sizeof (ArcBox)); //假定有足够空间\n        p->tailvex=i; p->headvex=j;\n        p->hlink=g->xlist[j].firstin; p->tlink=g->xlist[i].firstout;\n        g->xlist[j].firstin = g->xlist[i].firstout = p; //在入弧和出弧链头插入\n        }\n return; \n}\n47\n7.3",
    "2.4邻接多重表 (Adjacency Multilist)法\n邻接多重表：用于表示无向图\n所有顶点以一维数组方式组织\n每个顶点用一个顶点结点表示：\ndata域：存储和顶点相关的信息；\nfirstedge域：指向依附于该顶点的第一条边；\n每条边用一个边结点表示\nmark域：用以标识该条边是否被访问过；\nivex和jvex域：分别保存该边所依附的两个顶点在图中的位置；\ninfo域：保存该边的相关信息；\nilink域：指向下一条依附于顶点ivex的边；\njlink域：指向下一条依附于顶点jvex的边；",
    "邻接多重表的定义\n#define MAX_VERTEX_NUM  30  //最大顶点数\ntypedef  emnu {unvisited , visited}  VisitIf;\ntypedef struct Ebox {\n\tVisitIf  mark;    //访问标记\n\tint  ivex, jvex; //该边依附的两个结点在图中的位置\n\t//分别指向依附于这两个顶点的下一条边\n\tstruct EBox  *ilink, *jlink;\n\tInfoType    info  ;       //与边相关的信息, 如权值\n}EBox ;    //边结点\ntypedef struct VexBox { \n\tVertexType  data;     //顶点信息\n\tEBox  *firsedge ;      //指向依附于该顶点的第一条边\n}VerBox;    //顶点结点\ntypedef struct {\n\tint vexnum,edgenum; //无向图的顶点数和边数\n\tVerBox adjmulist[MAX_VERTEX_NUM]; \n}AMGraph ;",
    "邻接多重表与邻接表的区别\n邻接表的同一条边用两个结点表示，而邻接多重表只用一个结点表示\n邻接多重表能较方便地完成对边的操作\n标记已被搜索的边\n删除一条边\n除标志域外，邻接多重表与邻接表表达的信息是相同的，因此，操作的实现也基本相似\n无向图及其多重邻接链表\n∧\n∧\n∧"
  ],
  "Chapter+7-图-Part+2": [
    "第7章 图\nPart II\n1",
    "目录\n基本概念\n图的存储结构\n数组表示，邻接表表示\n(有向图)十字链表，(无向图)邻接多重表\n访问图的顶点：深度优先遍历，广度优先遍历\n排序(有向) 图的顶点：DAG/AOV网的拓扑排序\n图的连通性\n无向图的生成森林\n有向图的强连通分量\n关节点和重连通分量\n(连通带权图的)最小生成树：Prim算法，Kruskal算法\n(带权)图的路径\n关键路径/最长路径：有向无环带权图/AOE网\n最短路径：Dijkstra算法，Floyd算法\n2",
    "3. 图的遍历(Graph traversal)\n定义：从图的某一顶点出发，访问图中的其余顶点，每个顶点仅被访问一次\n遍历的复杂性：图的任意顶点可能和其余的顶点相邻接，可能在访问了某个顶点后，沿某条路径搜索后又回到原顶点\n解决办法：在遍历过程中记下已被访问过的顶点，即：设置一个辅助向量Visited[1…n](n为顶点数)，其初值为0，一旦访问了顶点vi后，设置Visited[i]为1或为访问的次序号\n算法：\n深度优先搜索算法和广度优先搜索算法\n采用的数据结构是(正)邻接链表",
    "(正)邻接表\n#define MAX_VERTEX_NUM 30\ntypedef char ElemType;\ntypedef struct node {\n    int vindex; \t//邻接点在表头结点数组中的位置(下标)\n    struct node *next; //指向下一个表结点\n} NodeLink; // 表结点类型定义\n\ntypedef struct {\n    // 图的顶点数、边数、种类标志\n    int vexnum, edgenum, kind; \n    struct {\n        ElemType vertex;\n        NodeLink *first;// 指向第一个表结点\n       } v[MAX_VERTEX_NUM];\n} AGraph;\n4",
    "3.1深度优先搜索(Depth First Search, DFS)\n设初始状态时图中的所有顶点均未被访问\n从图中某个顶点V0 出发，访问此顶点，然后依次从V0的未被访问的邻接点出发深度优先遍历图，直至图中所有和V0有路径相通的顶点都被访问到\n若图中尚有顶点未被访问，则选一个未曾被访问的顶点作为起点，重复上述过程，直到图中所有顶点都被访问到为止",
    "DFS\n访问顶点 V ;\nfor (V的邻接点即W1、W2、W3 )\n    若该邻接点W未被访问，\n    则从它出发进行深度优先遍历\n\nSG1、SG2 和 SG3 分别为含顶点W1、W2和W3 的子图\n深度优先搜索遍历连通图的过程类似于树的先根遍历\n\n如何判别V的邻接点是否被访问？\n解决的办法是为每个顶点设立一个 访问标志 visited[w]\n6",
    "DFS的递归实现-I\nint visited[MAX_VERTEX_NUM]; //访问标志数组，全局变量\n//Status (* VisitFunc)(int x); //函数变量，使得DFS不必设函数指针参数\n//从第x个顶点出发递归地深度优先遍历图g\nvoid DFS(AGraph *g,int x) { // x为结点数组下标\nNodeLink *p;\nvisited[x]=1; printf(\"%3c\",g->v[x].vertex);\n//VisitFunc(x); //访问第x个顶点\np=g->v[x].first;\nwhile(p){\n    if(!visited[p->vindex]) //对x的尚未访问的邻接顶点\n\t\tDFS(g,p->vindex);\n    p=p->next; \n    }\n}\n7\n7.4",
    "DFS的递归实现-II\n//对图G作深度优先遍历\nvoid DFSGraph(AGraph *g){\nint i;\nfor(i=0;i<g->vexnum;i++)     \n\tvisited[i]=0; //访问标志数组初始化\nfor(i=0;i<g->vexnum;i++)\n    \tif(!visited[i]) DFS(g,i);\n}\n8\nDFS的时间复杂度?\n7.5\n邻接表：O(n+e)",
    "T\nT\nT\nT\nT\nT\nT\nT\nT\na\nc\nh\nd\nk\nf\ne\nb\ng\na\nc\nh\nk\nf\ne\nd\nb\ng\n访问标志:\n访问次序:\na\nc\nh\nd\nk\nf\ne\n例子：遍历无向图/ 深度优先搜索\nDFS tree",
    "DFS\n在图上执行DFS，顶点的输出序列有：\nDFS Pre-order/前序：在递归调用DFS之前，将当前顶点压入队列(queue)\n求顶点之间的路径\nDFS Post-order/后序：在递归调用DFS之后，将当前顶点压入队列(queue)\nDFS Reverse Pre-order/逆前序：在递归调用DFS之前，将当前顶点压入栈(stack)\nDFS Reverse Post-order/逆后序：在递归调用DFS之后，将当前顶点压入栈(stack)\n对集合元素的拓扑排序\n回边：如果图上的某条边不在DFS生成树上，那么这条边叫做回边\n10",
    "3.2 广度优先搜索 (Breadth First Search, BFS)\n设初始状态时图中的所有顶点未被访问\n从图中的某个顶点V0出发，访问此顶点V0 ，然后依次访问V0的所有未被访问过的邻接点，之后按这些顶点被访问的先后次序依次访问它们的邻接点，直至图中所有和V0有路径相通的顶点都被访问到\n若图中尚有顶点未被访问，则选一个未曾被访问的顶点作为起点，重复上述过程，直到图中所有顶点都被访问到为止\n\n广度优先遍历类似树的按层次遍历的过程\n用广度优先遍历算法遍历图与深度优先遍历算法遍历图的唯一区别是邻接点搜索次序不同",
    "例子：遍历有向图/广度优先搜索\n从A开始的BFS次序是：A→ B → D → C →E\n(b)    G’的正邻接链表\n0\n1\n2\n3\n4\n有向图广度优先搜索遍历\n(a)   有向图G’\nA\nB\nC\nD\nE\n1\n2\n3\n4\n5\nMAX_VEXTEX\n_NUM-1\nBFS tree",
    "BFS的(非递归)实现-I\nvoid BFS(AGraph *G, Status (*Visit)(int v )) {\n//使用辅助队列Q，保存已访问过的顶点\n//使用访问标志数组visited，用于标记图中顶点是否被访问过\nLinkedQueue Q;\nQElemType v,w,u; \nfor (v=0; v<G->vexnum; ++v) visited[v] = FALSE;\nInitQueue(&Q); //置空的辅助队列Q \nfor (v=0; v<G->vexnum; ++v) \n… \n} // BFS\n13\n7.6",
    "BFS的(非递归)实现-II\nif (!visited[v]) {// v尚未访问\n\tvisited[v] = TRUE;  Visit(v); // 访问v \n\tEnQueue(&Q, v); // v入队列\n\twhile (!IsQueueEmpty(&Q)) { \n\t  DeQueue(&Q,&u); //队头元素出队并置为u \n\t  for (w=FirstAdjVex(G, u); w>=0; \n\t\t\tw=NextAdjVex(G, u, w)) \n\t          if (!visited[w]) { \n\t\t // u的尚未访问的邻接顶点w入队列Q \n\t\t visited[w] = TRUE; \n\t\t Visit(w); \n\t\t EnQueue(&Q, w); \n\t          }//if \n\t}//while\n  }//if\n14\nBFS的时间复杂度？\n邻接表：O(n+e)",
    "BFS 例子\n15\n执行BFS，依次访问顶点：\nA,B,D,E,C,G,F,H,I\n构造图：依次输入边信息，即，AB AD AE DG EG GH HI BC CF\nBFS tree",
    "BFS的另一种(非递归)实现\nvoid BFS(AGraph *g,int x) {\n// 用一个数组q作辅助队列, q[0..front)存放的是访问过的顶点, \n// q[front..rear)存放的是已访问顶点的相邻点，是马上要访问的顶点\nint q[MAX_VERTEX_NUM],front,rear,i; \nNodeLink *p;\nfront=rear=0; q[rear++]=x;\nwhile(front != rear) //队列非空\n{ //顶点出队列，并访问它\n    x=q[front++]; printf(\"%c->\",g->v[x].vertex); visited[x]=1;\n    p=g->v[x].first;\n    while(p!=NULL) {\n        for(i=0;i<rear;i++) //判邻接点是否在数组q中\n            if(p->vindex == q[i]) break;\n        if(i >=rear) //邻接点未被访问且不在队列中，则入队列\n            q[rear++]=p->vindex;\n        p=p->next; // 找x的下一个邻接点\n    }\n }\n}\n16",
    "BFS的(非递归)实现-II\nvoid BFSGraph(AGraph *g){\nint i;\nfor(i=0;i<g->vexnum;i++)\n    visited[i]=0;\nfor(i=0;i<g->vexnum;i++)\n    if(!visited[i]) BFS(g,i);\n}\n17",
    "3.3 图遍历的应用\n顶点之间的可达性检测\n顶点之间的路径求解\n顶点之间的最短距离\n(DAG/AOV的)拓扑排序\n\n图的连通性检测\n连通图的生成树，非连通图的生成森林\n有向图的强连通分量\n重连通图/连通图关节点的判定\n欧拉回路\n18",
    "应用1：求从一顶点到另一顶点的一条简单路径\n求从一顶点b到另一顶点i的一条简单路径\n从顶点 b 出发，进行深度优先搜索遍历\n深度优先搜索访问顶点的次序取决于图的存储结构\n假设找到的第一个邻接点是c,则得到的顶点访问序列为：\nb  c  h  d  a  e  i  f  g\n假设找到的第一个邻接点是a,且得到的顶点访问序列为：\nb  a  d  h  c  e  i  f  g\n从顶点 b 到顶点 i，若存在路径，则从顶点 b 出发进行深度优先搜索，必能搜索到顶点 i\n遍历过程中搜索到的顶点不一定是路径上的顶点！",
    "void DFSPath( int v, int s, char *PATH)  {\n //从第v个顶点出发递归地深度优先遍历图G，\n //求得一条从v到s的简单路径，并记录在PATH中  \n  visited[v] = TRUE;   // 访问第 v 个顶点\n           \n  for (w=FirstAdjVex(v);  w!=0                        ;\n                                w=NextAdjVex(v) )\n\n               if (!visited[w])  DFSPath (w, s, PATH);\n  \n}\nAppend(PATH, getVertex(v));   // 第v个顶点加入路径\n&&!found\nif (w=s) { found = TRUE;  Append(PATH, w); }\nelse\nif (!found)  Delete (PATH, v); // 从路径上删除顶点 v",
    "应用2：求两个顶点之间的一条最短路径\n例如：b和k两个顶点之间存在多条路径，求b到k的最短路径\n以广度优先搜索方式访问顶点的过程是相应的路径的长度渐增的过程\n求路径长度最短的路径可以基于广度优先搜索遍历进行\n需要记录路径\n需要修改链队列的结点结构以及修改其入队列和出队列的算法",
    "链队列的状态如下所示：\n求顶点3至顶点5的一条最短路径\n结点包含next 和\nprior两个指针",
    "为了记录路径\n将链队列的结点改为“双链”结点：结点中包含next 和prior两个指针；\n修改出队列的操作：出队列时，仅移动队头指针，而不将队头结点从链表中删除\n修改入队列的操作：插入新的队尾结点时，令其prior域的指针指向刚刚出队列的结点，即当前的队头指针所指结点；\n\n记录路径：通过prior指针记录路径",
    "void InitQueue(LinkQueue *Q) {\n  Q->front = Q->rear = (Qnode *)malloc(sizeof(Qnode));\n  Q->front->next = Q->rear->next = NULL;\n}\nvoid EnQueue( LinkQueue *Q, ElemType e ) {\n  p = (Qnode *) malloc(sizeof(Qnode));\n  p->data = e;  p->next = NULL;\n  p->prior = Q->front;\n  Q->rear->next = p;  Q->rear = p;\n}\nvoid DeQueue( LinkQueue *Q, ElemType *e ) {\n  Q->front = Q->front->next;  e = Q.front->data\n}",
    "4. 图的顶点排序：拓扑排序\n拓扑排序(Topological Sort)：由某个集合上的一个偏序得到该集合上的一个全序的操作\n偏序：若集合A上的关系R是自反的、反对称的和传递的，则称R是集合A上的偏序关系\n这时，集合中仅有部分元素之间可以比较\n全序：设R是集合A上的偏序关系，a，b∈A，必有aRb或bRa， 则称R是集合A上的全序关系\n这时，集合中任意两个元素之间都可以比较\n若集合元素之间存在偏序关系，那么，集合元素以及元素之间的关系可以用有向无环图(Directed Acycling Graph)表示\n集合元素的拓扑排序 转换成 图上的顶点排序\n25",
    "集合上的关系\n集合上的关系：集合A上的关系 R 是从A到A的关系(AA) \n关系的自反性：若a∈A有(a, a)∈R，称集合A上的关系R是自反的\n关系的对称性：如果对于a, b∈A ，只要有(a, b)∈R就有(b, a)∈R ，称集合A上的关系R是对称的\n关系的反对称性： 如果对于a, b∈A ，仅当a=b时有(a, b)∈R和(b,  a)∈R，称集合A上的关系R是反对称的\n实数集上的小于等于关系≤是反对称的\n关系的传递性：若a, b, c∈A，若(a, b)∈R，并且(b,  c)∈R ，则(a, c)∈R ，称集合A上的关系R是传递的",
    "AOV网\nAOV网(Activity On Vertex Network)：在有向图中，用顶点表示活动，用有向边表示活动之间的优先关系\nAOV网可用于表示工程活动：一个工程可分为若干个称为活动的子工程(或工序)，各个子工程受到一定的条件约束：某个子工程必须开始于另一个子工程完成之后；整个工程有一个开始点/起点和一个终止点/汇点\n借助于AOV网研究工程项目的工序问题、工程进度等\n工程应该按怎样的顺序进行? \n工程能否顺利完成?\n27",
    "DAG/AOV网的拓扑排序\nDAG/AOV网的拓扑排序：构造顶点的一个拓扑线性序列(v’1,v’2, ⋯,v’n)，使得该线性序列不仅保持原来有向图中顶点之间的优先关系，而且对原图中没有优先关系的顶点之间也建立一种(人为的)优先关系\n28\n拓扑排序\n偏序关系\n全序关系",
    "图的顶点排序：拓扑排序\nDAG/AOV网的拓扑排序：构造顶点的一个线性序列，使得该线性序列保持原来有向图中顶点之间的优先关系\n应用举例：\n看病流程\n选课流程\n工程步骤安排\n29\n拓扑排序\n全序关系",
    "拓扑排序算法\n算法思路\n选择一个入度为0(没有前驱)的顶点并输出\n在有多个入度为0的顶点的情况下，选择不同的顶点，会产生不同的拓扑排序结果\n删除该顶点以及从该顶点出发的(以该顶点为尾的弧)所有有向边\n重复执行前两步，直到：\n图中全部顶点都已输出(图中无环)，或，\n图中不存在无前驱的顶点(图中必有环)\n算法实现\n采用正邻接链表作为DAG/AOV网的存储结构\n设立栈，用来暂存入度为0的顶点\n也可以用队列来存储\n需要记录顶点的入度\n删除以该顶点为尾的弧：弧头顶点的入度减1\n需要记录已输出顶点的数目\n等于图的顶点数，则，图中无环，否则，图中有环",
    "算法实现-数据结构\n顶点入度值的计算和保存\n方案1：typedef struct node {\n    int vindex; //邻接点在头结点数组中的位置(下标)\n    int count;  //记录该顶点的入度\n    struct node *next; //指向下一个表结点\n} NodeLink;  //表结点类型定义\n\n方案2：int indegree[MAX_VERTEX_NUM]; //存放顶点的入度\nvoid FindIndegree(AGraph *g, int indegree[MAX_VERTEX_NUM]){\nNodeLink *p;\nfor(int i=0;i<g->vexnum;i++){\n    p=g->v[i].first;\n    while(p) { indegree[p->vindex]++; p=p->next; }\n     }\n}\n\n简易栈，用于存放零入度顶点\nchar stack[MAX_VERTEX_NUM]; int top=0;\n31\n统计各顶点的入度\n时间复杂度是O(n+e)",
    "Status TopologicalSort(AGraph *g) { NodeLink *p; … …\nfor(i=0;i<MAX_VERTEX_NUM;i++) indegree[i]=0;\nFindIndegree(g,indegree);\nfor(i=g->vexnum-1;i>=0;i--)  \t//for(i=0;i<g->vexnum;i++)\n        if(indegree[i]==0) {\t//入度为0者进栈\n\tstack[top]=i; top++; }\ncount=0; // 对输出顶点计数\nwhile (top!=0) {\n    top--; i=stack[top]; printf(\"%c\",g->v[i].vertex); count++;\n    for(p=g->v[i].first;p;p=p->next){\n        j=p->vindex; //对i号顶点的每个邻接点的入度减1\n        if(--indegree[j]==0){ //若入度减为0，则入栈\n\tstack[top]=j; top++;}\n        }\n} //while\nif(count<g->vexnum) return ERROR; //该图有回路\nelse return OK;\n}\n32\n7.12",
    "拓扑排序：算法时间复杂度分析\n设AOV网有n个顶点，e条边，则算法的主要执行是：\n统计各顶点的入度：时间复杂度是O(n+e) \n入度为0的顶点入栈：时间复杂度是O(n) \n排序过程：顶点入栈和出栈操作执行n次，入度减1的操作共执行e次，时间复杂度是O(n+e) \n因此，整个算法的时间复杂度是O(n+e)",
    "拓扑排序实例\n34\n拓扑排序结果：\nCABEFD或CABEDF\n或\nACBEFD或ACBEDF",
    "拓扑排序应用\n应用1：图的回路(环)的检查方法：对有向图的顶点进行拓扑排序，若所有顶点都在其拓扑有序序列中，则无环\n应用2：工程执行顺序/课程先修顺序： 对AOV网的顶点进行拓扑排序\nA                       高等数学\t\n  B                   程序设计基础\n  C                       离散数学                   A, B\n  D                       数据结构                   B, C\n  E               高级语言程序设计           B\n  F                       编译方法                   E, D\n  G                       操作系统                   D, I\n  H                       普通物理                   A\n  I                      计算机原理                 H\n课程及之间的先修关系：",
    "拓扑排序结果：不唯一\nB, E, A, C, D, F, H, I, G\nA, H, I, B, E, C, D, G, F\nA, B, C, D, E, F, H, I, G\nA         高等数学\t\n  B        程序设计基础\n  C        离散数学\n  D        数据结构\n  E        高级语言程序设计\n  F         编译方法\n  G         操作系统\n  H         普通物理\n  I         计算机原理",
    "思考题\n关于拓扑排序的说法\n拓扑排序成功仅限于有向无环图\n任何有向无环图的顶点都可以排到拓扑有序序列中，而且拓扑序列不唯一\n若有向图的邻接矩阵中对角线以下的元素均为0，则该图的拓扑排序序列必定存在\n在拓扑排序序列中任意两个相继排列的顶点vi和vj在有向无环图中都存在从vi到vj的路径\n是否可以用图的深度优先搜索算法获得拓扑排序效果的顶点序列？\n在DFS的每次递归结束并退出时将当前顶点压入一个栈，该栈从栈顶到栈底记录了一个拓扑有序序列\n前提：AOV网(图中无环)\n37"
  ]
}